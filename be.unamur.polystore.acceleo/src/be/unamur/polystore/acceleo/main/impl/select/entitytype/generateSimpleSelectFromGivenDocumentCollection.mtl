[comment encoding = UTF-8 /]
[module generateSimpleSelectFromGivenDocumentCollection('http://www.unamur.be/polystore/Pml')]
[import be::unamur::polystore::acceleo::main::mappingrules::util /]
[import be::unamur::polystore::acceleo::main::util /]

[comment get{E}List({E)AttributeCondition /]

[template public generateSimpleSelectFromGivenDocumentCollection(rel : RelationshipType, struct: AbstractPhysicalStructure, db : Database)]
[generateSimpleSelectFromGivenDocumentCollection(rel, struct, db,Sequence{})/]
[/template]

[template public generateSimpleSelectFromGivenDocumentCollection(rel : RelationshipType, struct: AbstractPhysicalStructure, db : Database, references : Sequence(Sequence(OclAny)))]
[generateSimpleSelectFromGivenDocumentCollection(rel.name.toUpperFirst(), rel, rel.attributes, struct, db, references)/]
[/template]	

[template public generateSimpleSelectFromGivenDocumentCollection(ent : EntityType, struct: AbstractPhysicalStructure, db : Database)]
[generateSimpleSelectFromGivenDocumentCollection(ent, struct, db, Sequence{})/]
[/template]

[template public generateSimpleSelectFromGivenDocumentCollection(ent : EntityType, struct: AbstractPhysicalStructure, db : Database, references : Sequence(Sequence(OclAny)))]
[generateSimpleSelectFromGivenDocumentCollection(ent.name.toUpperFirst(), ent, ent.attributes, struct, db, references)/]
[/template]	

[template public generateSelectFromGivenHybridDocumentCollection(rel: RelationshipType, struct: AbstractPhysicalStructure, db : Database)]
	List<String> bsons = new ArrayList<String>();
	String bson = null;
	[for (role : Role | rel.roles)]
	bson = [role.entity.name.toUpperFirst()/]ServiceImpl.getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /]([role.name + '_condition' /] ,[role.name/]_refilter);
	if(bson != null)
		bsons.add("{" + bson + "}");
	[/for]

	String bsonQuery = bsons.size() == 0 ? null : "{$match: { $and: [ '['/]" + String.join(",", bsons) + "[ ']'/] }}";

	Dataset<Row> dataset = dbconnection.SparkConnectionMgr.getSparkSessionForMongoDB("[db.name /]", "[struct.name /]", bsonQuery);

	Dataset<[rel.name.toUpperFirst() /]> res = dataset.flatMap((FlatMapFunction<Row, [rel.name.toUpperFirst() /]>) r -> {
			List<[rel.name.toUpperFirst() /]> list_res = new ArrayList<[rel.name.toUpperFirst() /]>();
			Integer groupIndex = null;
			String regex = null;
			String value = null;
			Pattern p = null;
			Matcher m = null;
			boolean matches = false;
			Row nestedRow = null;

			boolean addedInList = false;
			Row r1 = r;
			[rel.name.toUpperFirst() /] [rel.name.toLowerFirst() /]1 = new [rel.name.toUpperFirst() /]();
			[for (role : Role | rel.roles)]
			[rel.name.toLowerFirst() /]1.set[role.name.toUpperFirst() /](new [role.entity.name.toUpperFirst() /]());
			[/for]
			
			[generateHybridFlatMapBody(struct, rel, db, 1)/]
			
			return list_res.iterator();

	}, Encoders.bean([rel.name.toUpperFirst() /].class));
	// TODO drop duplicates based on roles ids
	//res= res.dropDuplicates(new String {});
	return res;
[/template]

[template public generateSimpleSelectFromGivenDocumentCollection(pojoName : String, entOrRel : OclAny, attributes : Collection(Attribute), struct: AbstractPhysicalStructure, db : Database, references : Sequence(Sequence(OclAny)))]
	String bsonQuery = [pojoName/]ServiceImpl.getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](condition, refilterFlag);
	if(bsonQuery != null) {
		bsonQuery = "{$match: {" + bsonQuery + "}}";	
	} 
	
	Dataset<Row> dataset = dbconnection.SparkConnectionMgr.getSparkSessionForMongoDB("[db.name /]", "[struct.name /]", bsonQuery);

	Dataset<[pojoName /][if (references->size() > 0)][getTDOLiteral('') /][/if]> res = dataset.flatMap((FlatMapFunction<Row, [pojoName /][if (references->size() > 0)][getTDOLiteral('') /][/if]>) r -> {
			List<[pojoName /][if (references->size() > 0)][getTDOLiteral('') /][/if]> list_res = new ArrayList<[pojoName /][if (references->size() > 0)][getTDOLiteral('') /][/if]>();
			Integer groupIndex = null;
			String regex = null;
			String value = null;
			Pattern p = null;
			Matcher m = null;
			boolean matches = false;
			Row nestedRow = null;

			boolean addedInList = false;
			Row r1 = r;
			[pojoName /][if (references->size() > 0)][getTDOLiteral('') /][/if] [pojoName.toLowerFirst() /]1 = new [pojoName /][if (references->size() > 0)][getTDOLiteral('') /][/if]();
			[if (references->size() = 0)]
				[generateFlatMapBody(struct, entOrRel, pojoName, db, 1)/]
			[else]
				[generateFlatMapBodyTDOObject(struct, entOrRel, pojoName, db, 1, references)/]
			[/if]
			
			return list_res.iterator();

	}, Encoders.bean([pojoName /][if (references->size() > 0)][getTDOLiteral('') /][/if].class));
	res= res.dropDuplicates(new String['['/][']'/]{[if (attributes->size() > 0 and entOrRel.oclIsTypeOf(EntityType))][for (attr : Attribute | attributes->any(true).ancestors(EntityType)->first().identifier.attributes) separator(',')]"[attr.name/]"[/for][/if]});
	return res;
[/template]

[template public generateBSONMatchQueryMethod(ent : EntityType, struct: AbstractPhysicalStructure, db : Database)]
[generateBSONMatchQueryMethod(ent.name.toUpperFirst(), ent.attributes, struct, db)/]
[/template]

[template public generateBSONMatchQueryMethod(rel : RelationshipType, struct: AbstractPhysicalStructure, db : Database)]
[generateBSONMatchQueryMethod(rel.name.toUpperFirst(), rel.attributes, struct, db)/]
[/template]


[template public generateBSONMatchQueryMethod(pojoName : String, attributes : Collection(Attribute), struct: AbstractPhysicalStructure, db : Database)]
public static String getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](Condition<[pojoName.toUpperFirst() /]Attribute> condition, MutableBoolean refilterFlag) {	
	String res = null;	
	if(condition != null) {
		if(condition instanceof SimpleCondition) {
			[pojoName /]Attribute attr = ((SimpleCondition<[pojoName /]Attribute>) condition).getAttribute();
			Operator op = ((SimpleCondition<[pojoName /]Attribute>) condition).getOperator();
			Object value = ((SimpleCondition<[pojoName /]Attribute>) condition).getValue();
			if(value != null) {
				String valueString = Util.transformBSONValue(value);
				boolean isConditionAttrEncountered = false;

				[for (attr : Attribute | attributes)]
				[let field : PhysicalField = getMappedPhysicalField(attr, struct, db, struct.ancestors(Domainmodel)->first().mappingRules)][if (field <> null)]
				if(attr == [pojoName.toUpperFirst() /]Attribute.[attr.name /] ) {
					isConditionAttrEncountered = true;
				[let ancestorsList : Sequence(EmbeddedObject) = field.ancestors(EmbeddedObject)]
				
				[if (field.ancestors(LongField) -> size() > 0)]
				String preparedValue = [getPreparedValue(attr, field, field.ancestors(LongField) -> first().oclAsType(LongField), false, false) /];
				boolean like_op = false;
				boolean not_like = false; 
				if(op == Operator.EQUALS && valueString != null && preparedValue.contains("[getPatternOtherValue() /]")) {
					//ex: @@VAR@@' '@@OTHERVAR@@"=> more than one vars in LongField: we shall use regex
					like_op = true;
					preparedValue = [getPreparedValue(attr, field, field.ancestors(LongField) -> first().oclAsType(LongField), false, true) /];
				} else {
					if(op == Operator.NOT_EQUALS && valueString != null && preparedValue.contains("[getPatternOtherValue() /]")) {
						//ex: @@VAR@@' '@@OTHERVAR@@"=> more than one vars in LongField: we shall use regex
						not_like = true;
						like_op = true;
						preparedValue = [getPreparedValue(attr, field, field.ancestors(LongField) -> first().oclAsType(LongField), false, true) /];
					}
				}
				if(op == Operator.CONTAINS && valueString != null) {
					like_op = true;
					preparedValue = [getPreparedValue(attr, field, field.ancestors(LongField) -> first().oclAsType(LongField), false, true) /];
					preparedValue = preparedValue.replaceAll("[getPatternValue() /]", ".*[getPatternValue() /].*");
				}
					
				if(like_op)
					valueString = Util.escapeReservedRegexMongo(valueString);
				preparedValue = preparedValue.replaceAll("[getPatternValue() /]", valueString).replaceAll("[getPatternOtherValue() /]", ".*");
				
				if(valueString.equals(preparedValue)) // 5 <=> 5, the preparedValue is the same type as the original value
					preparedValue = Util.getDelimitedMongoValue(value.getClass(), preparedValue);
				else // 5 => 5*, the preparedValue became a string
					preparedValue = Util.getDelimitedMongoValue(String.class, preparedValue);
					

				String mongoOp = (like_op) ? "$regex" : op.getMongoDBOperator();
				//if not_like = true then we need to complement/negate the given regex
				res = "[getPhysicalName(field)/]': {" + (!not_like ? (mongoOp + ": " + preparedValue) : ("$not: {" + mongoOp + ": " + preparedValue + "}")) + "}";
				[else]
					String mongoOp = op.getMongoDBOperator();
					String preparedValue = valueString;
					if(op == Operator.CONTAINS && valueString != null) {
						preparedValue = "'.*" + Util.escapeReservedRegexMongo(valueString)  + ".*'";
					} else {
						preparedValue = Util.getDelimitedMongoValue(value.getClass(), preparedValue);
					}
					res = "[getPhysicalName(field) /]': {" + mongoOp + ": " + preparedValue + "}";
				[/if]

				[if (ancestorsList->size() > 0)]
				[comment level-n field, with n > 1 /]
				[for (ancestor : EmbeddedObject | ancestorsList)]
					res = "[ancestor.name /]." + res;
				[/for]
				[/if]
				res = "'" + res;
				[/let]
				}
				[/if]
				[/let]
				[/for]
				if(!isConditionAttrEncountered) {
					refilterFlag.setValue(true);
					res = "$expr: {$eq:[ '[' /]1,1[ ']' /]}";
				}
				
			}
		}

		if(condition instanceof AndCondition) {
			String bsonLeft = getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](((AndCondition)condition).getLeftCondition(), refilterFlag);
			String bsonRight = getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](((AndCondition)condition).getRightCondition(), refilterFlag);			
			if(bsonLeft == null && bsonRight == null)
				return null;
			if(bsonLeft == null)
				return bsonRight;
			if(bsonRight == null)
				return bsonLeft;
			res = " $and: [ '[' /] {" + bsonLeft + "}, {" + bsonRight + "}[ ']' /] ";
		}

		if(condition instanceof OrCondition) {
			String bsonLeft = getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](((OrCondition)condition).getLeftCondition(), refilterFlag);
			String bsonRight = getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](((OrCondition)condition).getRightCondition(), refilterFlag);			
			if(bsonLeft == null && bsonRight == null)
				return null;
			if(bsonLeft == null)
				return bsonRight;
			if(bsonRight == null)
				return bsonLeft;
			res = " $or: [ '[' /] {" + bsonLeft + "}, {" + bsonRight + "}[ ']' /] ";	
		}

		

		
	}

	return res;
}
[/template]



[template private generateHybridFlatMapBody(arg : OclAny, rel: RelationshipType, db : Database, level : Integer)]
boolean toAdd[level /]  = false;
WrappedArray array[level /]  = null;
[for (child : PhysicalField | getChildrenNonArrayPhysicalFields(arg))]
[let mappedAttrList : Collection(Attribute) = getMappedAttributesFromMultipleEntityTypes(child, rel.roles -> collect(role : Role | role.entity)->asSet(), db.ancestors(Domainmodel)->first().mappingRules)]
[if (mappedAttrList->size() > 0)]
[for (attr : Attribute | mappedAttrList)]
[let entity : EntityType = attr.ancestors(EntityType) -> any(true)]
[let ancestorsList : Sequence(EmbeddedObject) = getSequenceOfNonArrayEmbeddedObjects(child)]
// 	attribute [entity.name /].[attr.name /] for field [getPhysicalName(child) /]			
nestedRow =  r[level /];
[for (anc : EmbeddedObject | ancestorsList->reverse())]
[comment simple row /]
nestedRow = (nestedRow == null) ? null : (Row) nestedRow.getAs("[getPhysicalName(anc)/]");
[/for]
[/let]
if(nestedRow != null && Arrays.asList(nestedRow.schema().fieldNames()).contains("[getPhysicalName(child)/]")) {
	[if (child.ancestors(LongField) -> size() = 0)]
	[comment shortField or bracketfield/]
	if(nestedRow.getAs("[getPhysicalName(child)/]")==null)
		[rel.name.toLowerFirst() /][level/].get[rel.roles->select(role : Role | role.entity = entity )->any(true).name.toUpperFirst() /]().set[attr.name.toUpperFirst() /](null);
	else{
		[rel.name.toLowerFirst() /][level/].get[rel.roles->select(role : Role | role.entity = entity )->any(true).name.toUpperFirst() /]().set[attr.name.toUpperFirst() /](Util.get[generateJavaType(attr.type) /]Value(nestedRow.getAs("[getPhysicalName(child)/]")));
		toAdd[level/] = true;					
		}
	[else]
		[if (child.ancestors(LongField) -> first().oclAsType(LongField).pattern->size() = 1)][comment if you encounter a "short" long field. E.g., rate: rating  /]
	if(nestedRow.getAs("[getPhysicalName(child.ancestors(LongField) -> first().oclAsType(LongField)) /]")==null)
		[rel.name.toLowerFirst() /][level/].get[rel.roles->select(role : Role | role.entity = entity )->any(true).name.toUpperFirst() /]().set[attr.name.toUpperFirst() /](null)
	else{
		[rel.name.toLowerFirst() /][level/].get[rel.roles->select(role : Role | role.entity = entity )->any(true).name.toUpperFirst() /]().set[attr.name.toUpperFirst() /](Util.get[generateJavaType(attr.type) /]Value(nestedRow.getAs("[getPhysicalName(child.ancestors(LongField) -> first().oclAsType(LongField)) /]")));
		toAdd[level/] = true;	
		}
		[else]
	[comment LongField /]
	regex = "[getJavaRegexFromLongField(child.ancestors(LongField) -> first().oclAsType(LongField)) /]";
	groupIndex = [getPositionInLongField(child, child.ancestors(LongField) -> first().oclAsType(LongField))/];
	if(groupIndex == null) {
		throw new Exception("Cannot retrieve value for [entity.name /].[attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
	}
	value = nestedRow.getAs("[child.ancestors(LongField) -> first().oclAsType(LongField).physicalName /]");
	p = Pattern.compile(regex);
	m = p.matcher(value);
	matches = m.find();
	if(matches) {
		String [attr.name.toLowerFirst()/] = m.group(groupIndex.intValue());
		[rel.name.toLowerFirst() /][level/].get[rel.roles->select(role : Role | role.entity = entity )->any(true).name.toUpperFirst() /]().set[attr.name.toUpperFirst()/]([generateParsingFunctionJavaType(attr.type, attr.name.toLowerFirst())/]);
		toAdd[level/] = true;
	} else {
		throw new Exception("Cannot retrieve value for [entity.name /].[attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
	}
		[/if]
	[/if]
}
[/let]
[/for]
[/if]
[/let]
[/for]
[let children : Collection(EmbeddedObject) = getChildrenArrayPhysicalFieldsHavingDescendantMappedToGivenEntityTypes(arg, rel.roles -> collect(role : Role | role.entity)->asSet(), rel.ancestors(Domainmodel)->first().mappingRules)]
[if (children->size() > 0)]
[for (child : EmbeddedObject | children)]
array[level /] = r[level /].getAs("[getPhysicalName(child)/]");
if(array[level /]!= null) {
	for (int i[level + 1/] = 0; i[level + 1/] < array[level /].size(); i[level + 1/]++){
		Row r[level + 1 /] = (Row) array[level /].apply(i[level + 1/]);
		[rel.name.toUpperFirst() /] [rel.name.toLowerFirst() /][level + 1/] = ([rel.name.toUpperFirst() /]) [rel.name.toLowerFirst() /][level/].clone();
		[generateHybridFlatMapBody(child, rel, db, level + 1)/]
	}
}

if(toAdd[level /] [if (level > 1)]&& ([for (role : Role | rel.roles) separator('&&')]([role.name/]_condition == null || [role.name/]_refilter.booleanValue() || [role.name/]_condition.evaluate([rel.name.toLowerFirst() /][level /].get[role.name.toUpperFirst()/]()))[/for])[/if]) {
	list_res.add([rel.name.toLowerFirst() /][level /]);
	addedInList = true;
} 
[if (level > 1)]if(addedInList)
	toAdd[level - 1 /] = false;[/if]

[/for]
[else]
if(toAdd[level /] [if (level > 1)]&& ([for (role : Role | rel.roles) separator('&&')]([role.name/]_condition == null || [role.name/]_refilter.booleanValue() || [role.name/]_condition.evaluate([rel.name.toLowerFirst() /][level /].get[role.name.toUpperFirst()/]()))[/for])[/if]) {
	list_res.add([rel.name.toLowerFirst() /][level /]);
	addedInList = true;
} 
[if (level > 1)]if(addedInList)
	toAdd[level - 1 /] = false;[/if]
[/if]
[/let]
[/template]


[template private generateFlatMapBody(arg : OclAny, entOrRel : OclAny, pojoName : String, db : Database, level : Integer)]
boolean toAdd[level /]  = false;
WrappedArray array[level /]  = null;
[for (child : PhysicalField | getChildrenNonArrayPhysicalFields(arg))]
[let mappedAttrList : Collection(Attribute) = getMappedAttributes(child, entOrRel, db.ancestors(Domainmodel)->first().mappingRules)]
[if (mappedAttrList->size() > 0)]
[for (attr : Attribute | mappedAttrList)]
[let ancestorsList : Sequence(EmbeddedObject) = getSequenceOfNonArrayEmbeddedObjects(child)]
// 	attribute [pojoName /].[attr.name /] for field [getPhysicalName(child) /]			
nestedRow =  r[level /];
[for (anc : EmbeddedObject | ancestorsList->reverse())]
[comment simple row /]
nestedRow = (nestedRow == null) ? null : (Row) nestedRow.getAs("[getPhysicalName(anc)/]");
[/for]
[/let]
if(nestedRow != null && Arrays.asList(nestedRow.schema().fieldNames()).contains("[getPhysicalName(child)/]")) {
	[if (child.ancestors(LongField) -> size() = 0)]
	[comment shortField or bracketfield/]
	if(nestedRow.getAs("[getPhysicalName(child)/]")==null)
		[pojoName.toLowerFirst() /][level/].set[attr.name.toUpperFirst() /](null);
	else{
		[pojoName.toLowerFirst() /][level/].set[attr.name.toUpperFirst() /](Util.get[generateJavaType(attr.type) /]Value(nestedRow.getAs("[getPhysicalName(child) /]")));
		toAdd[level/] = true;					
		}
	[else]
		[if (child.ancestors(LongField) -> first().oclAsType(LongField).pattern->size() = 1)][comment if you encounter a "short" long field. E.g., rate: rating  /]
	if(nestedRow.getAs("[getPhysicalName(child.ancestors(LongField) -> first().oclAsType(LongField)) /]")==null)
		[pojoName.toLowerFirst() /][level/].set[attr.name.toUpperFirst() /](null);
	else{
		if(Arrays.asList(nestedRow.schema().fieldNames()).contains("[getPhysicalName(child.ancestors(LongField) -> first().oclAsType(LongField)) /]")){
			[pojoName.toLowerFirst() /][level/].set[attr.name.toUpperFirst() /](Util.get[generateJavaType(attr.type) /]Value(nestedRow.getAs("[getPhysicalName(child.ancestors(LongField) -> first().oclAsType(LongField)) /]")));
			toAdd[level/] = true;	
			}
		}
		[else]
	[comment LongField /]
	regex = "[getJavaRegexFromLongField(child.ancestors(LongField) -> first().oclAsType(LongField)) /]";
	groupIndex = [getPositionInLongField(child, child.ancestors(LongField) -> first().oclAsType(LongField))/];
	if(groupIndex == null) {
		throw new Exception("Cannot retrieve value for [pojoName /].[attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
	}
	value = nestedRow.getAs("[child.ancestors(LongField) -> first().oclAsType(LongField).physicalName /]");
	p = Pattern.compile(regex);
	m = p.matcher(value);
	matches = m.find();
	if(matches) {
		String [attr.name.toLowerFirst()/] = m.group(groupIndex.intValue());
		[pojoName.toLowerFirst() /][level/].set[attr.name.toUpperFirst()/]([generateParsingFunctionJavaType(attr.type, attr.name.toLowerFirst())/]);
		toAdd[level/] = true;
	} else {
		throw new Exception("Cannot retrieve value for [pojoName /].[attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
	}
		[/if]
	[/if]
}
[/for]
[/if]
[/let]
[/for]
[let children : Collection(EmbeddedObject) = getChildrenArrayPhysicalFieldsHavingDescendantMappedToGivenEntityType(arg, entOrRel, entOrRel.ancestors(Domainmodel)->first().mappingRules)]
[if (children->size() > 0)]
[for (child : EmbeddedObject | children)]
array[level /] = r[level /].getAs("[getPhysicalName(child)/]");
if(array[level /]!= null) {
	for (int i[level + 1/] = 0; i[level + 1/] < array[level /].size(); i[level + 1/]++){
		Row r[level + 1 /] = (Row) array[level /].apply(i[level + 1/]);
		[pojoName /] [pojoName.toLowerFirst() /][level + 1/] = ([pojoName /]) [pojoName.toLowerFirst() /][level/].clone();
		[generateFlatMapBody(child, entOrRel, pojoName, db, level + 1)/]
	}
}

if(toAdd[level /][if (level > 1)]&& (condition == null || refilterFlag.booleanValue() || condition.evaluate([pojoName.toLowerFirst() /][level /]))[/if]) {
	list_res.add([pojoName.toLowerFirst() /][level /]);
	addedInList = true;
} 
[if (level > 1)]if(addedInList)
	toAdd[level - 1 /] = false;[/if]

[/for]
[else]
if(toAdd[level /][if (level > 1)]&& (condition ==null || refilterFlag.booleanValue() || condition.evaluate([pojoName.toLowerFirst() /][level /]))[/if]) {
	list_res.add([pojoName.toLowerFirst() /][level /]);
	addedInList = true;
} 
[if (level > 1)]if(addedInList)
	toAdd[level - 1 /] = false;[/if]
[/if]
[/let]
[/template]

[template private generateFlatMapBodyTDOObject(arg : OclAny, entOrRel : OclAny, pojoName : String, db : Database, level : Integer, references : Sequence(Sequence(OclAny)))]
boolean toAdd[level /]  = false;
WrappedArray array[level /]  = null;
[for (child : PhysicalField | getChildrenNonArrayPhysicalFields(arg))]
[let mappedAttrList : Collection(Attribute) = getMappedAttributes(child, entOrRel, entOrRel.ancestors(Domainmodel)->first().mappingRules)]
[if (mappedAttrList->size() > 0)]
[for (attr : Attribute | mappedAttrList)]
[let ancestorsList : Sequence(EmbeddedObject) = getSequenceOfNonArrayEmbeddedObjects(child)]
// 	attribute [pojoName /].[attr.name /] for field [getPhysicalName(child) /]			
nestedRow =  r[level /];
[for (anc : EmbeddedObject | ancestorsList->reverse())]
[comment simple row /]
nestedRow = (nestedRow == null) ? null : (Row) nestedRow.getAs("[getPhysicalName(anc)/]");
[/for]
[/let]
if(nestedRow != null && Arrays.asList(nestedRow.schema().fieldNames()).contains("[getPhysicalName(child) /]")) {
	[if (child.ancestors(LongField) -> size() = 0)]
	[comment shortField or bracketfield/]
	if(nestedRow.getAs("[getPhysicalName(child)/]") == null){
		[pojoName.toLowerFirst() /][level/].set[attr.name.toUpperFirst() /](null);
	}else{
		[pojoName.toLowerFirst() /][level/].set[attr.name.toUpperFirst() /](Util.get[generateJavaType(attr.type) /]Value(nestedRow.getAs("[getPhysicalName(child) /]")));
		toAdd[level/] = true;					
		}
	[else]
		[if (child.ancestors(LongField) -> first().oclAsType(LongField).pattern->size() = 1)][comment if you encounter a "short" long field. E.g., rate: rating  /]
	if(nestedRow.getAs("[getPhysicalName(child.ancestors(LongField) -> first().oclAsType(LongField)) /]")==null)
		[pojoName.toLowerFirst() /][if (references->size() > 0)][getTDOLiteral('') /][/if][level/].set[attr.name.toUpperFirst() /](null);
	else{
		[pojoName.toLowerFirst() /][if (references->size() > 0)][getTDOLiteral('') /][/if][level/].set[attr.name.toUpperFirst() /](Util.get[generateJavaType(attr.type) /]Value(nestedRow.getAs("[getPhysicalName(child.ancestors(LongField) -> first().oclAsType(LongField)) /]")));
		toAdd[level/] = true;	
	}
		[else]
	[comment LongField /]
	regex = "[getJavaRegexFromLongField(child.ancestors(LongField) -> first().oclAsType(LongField)) /]";
	groupIndex = [getPositionInLongField(child, child.ancestors(LongField) -> first().oclAsType(LongField))/];
	if(groupIndex == null) {
		throw new Exception("Cannot retrieve value for [pojoName/].[attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
	}
	value = nestedRow.getAs("[child.ancestors(LongField) -> first().oclAsType(LongField).physicalName /]");
	p = Pattern.compile(regex);
	m = p.matcher(value);
	matches = m.find();
	if(matches) {
		String [attr.name.toLowerFirst()/] = m.group(groupIndex.intValue());
		[pojoName.toLowerFirst() /][level/].set[attr.name.toUpperFirst()/]([generateParsingFunctionJavaType(attr.type, attr.name.toLowerFirst())/]);
		toAdd[level/] = true;
	} else {
		throw new Exception("Cannot retrieve value for [pojoName /].[attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
	}
		[/if]
	[/if]
}
[/for]
[/if]
[/let]
[/for]

[for (pair : Sequence(OclAny) | references)]
[let ref : Reference = pair->at(1)]
[let refFields : Sequence(PhysicalField) = pair->at(2)]
[for (refField : PhysicalField | refFields)]
[comment Ici r�it�rer sur 'child' et v�fifier ce n'est aps le refField Si oui appliquer comme au dessus /]
[for (child : PhysicalField | getChildrenNonArrayPhysicalFields(arg))]
[if (child.getPhysicalName() = refField.getPhysicalName())]
	// field  [getPhysicalName(child) /] for reference [ref.name/] . Reference field : [getPhysicalName(refField)/]
[let ancestorsList : Sequence(EmbeddedObject) = getSequenceOfNonArrayEmbeddedObjects(child)]
nestedRow =  r[level /];
[for (anc : EmbeddedObject | ancestorsList->reverse())]
[comment simple row /]
nestedRow = (nestedRow == null) ? null : (Row) nestedRow.getAs("[getPhysicalName(anc)/]");
[/for]
[/let]
if(nestedRow != null) {
	[if (child.ancestors(LongField) -> size() = 0)]
		[if (child.oclIsTypeOf(ArrayField))]
	// Reference is in an Array Field
	[pojoName.toLowerFirst() /][level/].set[getJavaAbsolutePath(ref).toUpperFirst() /]_[refField.getPhysicalName() /](nestedRow.getAs("[refField.getPhysicalName() /]") == null ? null : ScalaUtil.javaList(nestedRow.getAs("[refField.getPhysicalName() /]")));
		[else]
	[pojoName.toLowerFirst() /][level/].set[getJavaAbsolutePath(ref).toUpperFirst() /]_[refField.getPhysicalName() /](nestedRow.getAs("[refField.getPhysicalName() /]") == null ? null : nestedRow.getAs("[refField.getPhysicalName() /]").toString());
		[/if]
	[comment shortField or bracketfield/]
	toAdd[level/] = true;					
	[else]
		[if (child.ancestors(LongField) -> first().oclAsType(LongField).pattern->size() = 1)][comment if you encounter a "short" long field. E.g., rate: rating  /]
	[pojoName.toLowerFirst() /][getTDOLiteral(ref) /][level/].set[getJavaAbsolutePath(ref).toUpperFirst() /]_[refField.getPhysicalName() /]((String) nestedRow.getAs("[getPhysicalName(child.ancestors(LongField) -> first().oclAsType(LongField)) /]"));
	toAdd[level/] = true;	
		[else]
	[comment LongField /]
	regex = "[getJavaRegexFromLongField(child.ancestors(LongField) -> first().oclAsType(LongField)) /]";
	groupIndex = [getPositionInLongField(child, child.ancestors(LongField) -> first().oclAsType(LongField))/];
	if(groupIndex == null) {
		logger.warn("Cannot retrieve value for [pojoName /][refField.getPhysicalName() /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
		throw new Exception("Cannot retrieve value for [pojoName /][refField.getPhysicalName() /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
	}
	value = nestedRow.getAs("[child.ancestors(LongField) -> first().oclAsType(LongField).physicalName /]");
	p = Pattern.compile(regex);
	m = p.matcher(value);
	matches = m.find();
	if(matches) {
		String [getJavaAbsolutePath(ref) /]_[refField.getPhysicalName() /] = m.group(groupIndex.intValue());
		[pojoName.toLowerFirst() /][getTDOLiteral(ref) /][level/].set[getJavaAbsolutePath(ref).toUpperFirst() /]_[refField.getPhysicalName() /]([getJavaAbsolutePath(ref) /]_[refField.getPhysicalName() /]);
		toAdd[level/] = true;
	} else {
		logger.warn("Cannot retrieve value for [pojoName /][refField.getPhysicalName() /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
		throw new Exception("Cannot retrieve value for [pojoName /][refField.getPhysicalName() /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
	}
		[/if]
	[/if]
}
[/if]
[/for]
[/for]
[/let]
[/let]
[/for]

[comment  /]

[comment Ici modifier �galement afin d'aller voir dans les multi value complex object si l'objet refField n'y est pas./]
[for (pair : Sequence(OclAny) | references)]
[let ref : Reference = pair->at(1)]
[let refFields : Sequence(PhysicalField) = pair->at(2)]
[let children : Collection(PhysicalField) = getChildrenArrayPhysicalFieldsHavingDescendantMappedToGivenEntityTypeOrToRefField(arg, entOrRel, entOrRel.ancestors(Domainmodel)->first().mappingRules, refFields)]
[if (children->size() > 0)]
[for (child : PhysicalField | children)]
array[level /] = r[level /].getAs("[getPhysicalName(child)/]");
if(array[level /]!= null) {
	for (int i[level + 1/] = 0; i[level + 1/] < array[level /].size(); i[level + 1/]++){
		Row r[level + 1 /] = (Row) array[level /].apply(i[level + 1/]);
		[pojoName /][getTDOLiteral(ref) /] [pojoName.toLowerFirst() /][level + 1/] = ([pojoName /][getTDOLiteral(ref) /]) [pojoName.toLowerFirst() /][level/].clone();
		[generateFlatMapBodyTDOObject(child, entOrRel,pojoName, db, level + 1, Sequence{Sequence{ref, refFields}})/]
	}
}

if(toAdd[level /][if (level > 1)]&&((condition == null || refilterFlag.booleanValue() || condition.evaluate([pojoName.toLowerFirst() /][level /])))[/if]) {
	list_res.add([pojoName.toLowerFirst() /][level /]);
	addedInList = true;
} 
[if (level > 1)]if(addedInList)
	toAdd[level - 1 /] = false;[/if]

[/for]
[else]
if(toAdd[level /][if (level > 1)]&&((condition ==null || refilterFlag.booleanValue() || condition.evaluate([pojoName.toLowerFirst() /][level /])))[/if]) {
	list_res.add([pojoName.toLowerFirst() /][level /]);
	addedInList = true;
} 
[if (level > 1)]if(addedInList)
	toAdd[level - 1 /] = false;[/if]
[/if]
[/let]
[/let]
[/let]
[/for]

[/template]

[query private getChildrenNonArrayPhysicalFields(arg : OclAny) : Collection(PhysicalField) =  
	invoke('be.unamur.polystore.acceleo.main.utils.Util', 'getChildrenNonArrayPhysicalFields(java.lang.Object)', Sequence{arg})
/]

[query public getMappedAttributesFromMultipleEntityTypes(field : PhysicalField, entities : Set(EntityType), rules : MappingRules) :  Collection(Attribute) = 
entities->collect(entity : EntityType | getMappedAttributes(field, entity, rules))->flatten()/]


[query private getMappedAttributes(field: PhysicalField, entOrRel: OclAny, rules: MappingRules) : Collection(Attribute) =  
	invoke('be.unamur.polystore.acceleo.main.utils.Util', 'getMappedAttributes(be.unamur.polystore.pml.PhysicalField, java.lang.Object, be.unamur.polystore.pml.MappingRules)', Sequence{field, entOrRel, rules})
/]

[query private getChildrenArrayPhysicalFieldsHavingDescendantMappedToGivenEntityType(arg : OclAny, entOrRel: OclAny, rules: MappingRules) : Collection(EmbeddedObject) =  
	invoke('be.unamur.polystore.acceleo.main.utils.Util', 'getChildrenArrayPhysicalFieldsHavingDescendantMappedToGivenEntityType(java.lang.Object, java.lang.Object, be.unamur.polystore.pml.MappingRules)', Sequence{arg, entOrRel, rules})
/]

[query private getChildrenArrayPhysicalFieldsHavingDescendantMappedToGivenEntityTypes(arg : OclAny, entities: Set(EntityType), rules: MappingRules) : Collection(EmbeddedObject) = 
entities->collect(entity : EntityType | getChildrenArrayPhysicalFieldsHavingDescendantMappedToGivenEntityType(arg, entity, rules))->flatten()/]


[query private getChildrenArrayPhysicalFieldsHavingDescendantMappedToGivenEntityTypeOrToRefField(arg : OclAny, entOrRel: OclAny, rules: MappingRules, refFields: Collection(PhysicalField)) : Collection(EmbeddedObject) =  
	invoke('be.unamur.polystore.acceleo.main.utils.Util', 'getChildrenArrayPhysicalFieldsHavingDescendantMappedToGivenEntityTypeOrToRefField(java.lang.Object, java.lang.Object, be.unamur.polystore.pml.MappingRules, java.util.List)', Sequence{arg, entOrRel, rules, refFields})
/]

[query private getSequenceOfNonArrayEmbeddedObjects(field : OclAny) : Sequence(EmbeddedObject) =  
	invoke('be.unamur.polystore.acceleo.main.utils.Util', 'getSequenceOfNonArrayEmbeddedObjects(org.eclipse.emf.ecore.EObject)', Sequence{field})
/]


[template public getTDOLiteral(o : OclAny)][if (o.oclIsUndefined() = false)]TDO[/if][/template]
