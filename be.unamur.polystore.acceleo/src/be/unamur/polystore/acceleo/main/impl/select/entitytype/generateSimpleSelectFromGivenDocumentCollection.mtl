[comment encoding = UTF-8 /]
[module generateSimpleSelectFromGivenDocumentCollection('http://www.unamur.be/polystore/Pml')]
[import be::unamur::polystore::acceleo::main::mappingrules::util /]
[import be::unamur::polystore::acceleo::main::util /]

[comment get{E}List({E)AttributeCondition /]

[template public generateSimpleSelectFromGivenDocumentCollection(rel : RelationshipType, struct: AbstractPhysicalStructure, db : Database)]
[generateSimpleSelectFromGivenDocumentCollection(rel, struct, db,Sequence{})/]
[/template]

[template public generateSimpleSelectFromGivenDocumentCollection(rel : RelationshipType, struct: AbstractPhysicalStructure, db : Database, references : Sequence(Sequence(OclAny)))]
[generateSimpleSelectFromGivenDocumentCollection(rel.name.toUpperFirst(), rel, rel.attributes, struct, db, references)/]
[/template]	

[template public generateSimpleSelectFromGivenDocumentCollection(ent : EntityType, struct: AbstractPhysicalStructure, db : Database)]
[generateSimpleSelectFromGivenDocumentCollection(ent, struct, db, Sequence{})/]
[/template]

[template public generateSimpleSelectFromGivenDocumentCollection(ent : EntityType, struct: AbstractPhysicalStructure, db : Database, references : Sequence(Sequence(OclAny)))]
[generateSimpleSelectFromGivenDocumentCollection(ent.name.toUpperFirst(), ent, ent.attributes, struct, db, references)/]
[/template]	

[template public generateSelectFromGivenHybridDocumentCollection(rel: RelationshipType, struct: AbstractPhysicalStructure, db : Database)]
	List<String> bsons = new ArrayList<String>();
	String bson = null;
	[for (role : Role | rel.roles)]
	bson = [role.entity.name.toUpperFirst()/]ServiceImpl.getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /]([role.name + '_condition' /] ,[role.name/]_refilter);
	if(bson != null)
		bsons.add("{" + bson + "}");
	[/for]

	String bsonQuery = bsons.size() == 0 ? null : "{$match: { $and: [ '['/]" + String.join(",", bsons) + "[ ']'/] }}";

	Dataset<Row> dataset = dbconnection.SparkConnectionMgr.getDatasetFromMongoDB("[db.name /]", "[struct.name /]", bsonQuery);

	Dataset<[rel.name.toUpperFirst() /]> res = dataset.flatMap((FlatMapFunction<Row, [rel.name.toUpperFirst() /]>) r -> {
			List<[rel.name.toUpperFirst() /]> list_res = new ArrayList<[rel.name.toUpperFirst() /]>();
			Integer groupIndex = null;
			String regex = null;
			String value = null;
			Pattern p = null;
			Matcher m = null;
			boolean matches = false;
			Row nestedRow = null;

			boolean addedInList = false;
			Row r1 = r;
			[rel.name.toUpperFirst() /] [rel.name.toLowerFirst() /]1 = new [rel.name.toUpperFirst() /]();
			[for (role : Role | rel.roles)]
			[rel.name.toLowerFirst() /]1.set[role.name.toUpperFirst() /](new [role.entity.name.toUpperFirst() /]());
			[/for]
			
			[generateHybridFlatMapBody(struct, rel, db, 1)/]
			
			return list_res.iterator();

	}, Encoders.bean([rel.name.toUpperFirst() /].class));
	// TODO drop duplicates based on roles ids
	res= res.dropDuplicates(new String['['/][']'/]{[for (role : Role | rel.roles) separator (',')][for (attr : Attribute | role.entity.identifier.attributes) separator(',')]"[role.name.toLowerFirst()/].[attr.name/]"[/for][/for]});
	return res;
[/template]

[template public generateSimpleSelectFromGivenDocumentCollection(pojoName : String, entOrRel : OclAny, attributes : Collection(Attribute), struct: AbstractPhysicalStructure, db : Database, references : Sequence(Sequence(OclAny)))]
	String bsonQuery = [pojoName/]ServiceImpl.getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](condition, refilterFlag);
	if(bsonQuery != null) {
		bsonQuery = "{$match: {" + bsonQuery + "}}";	
	} 
	
	Dataset<Row> dataset = dbconnection.SparkConnectionMgr.getDatasetFromMongoDB("[db.name /]", "[struct.name /]", bsonQuery);

	Dataset<[pojoName /][if (references->size() > 0)][getTDOLiteral('') /][/if]> res = dataset.flatMap((FlatMapFunction<Row, [pojoName /][if (references->size() > 0)][getTDOLiteral('') /][/if]>) r -> {
			Set<[pojoName /][if (references->size() > 0)][getTDOLiteral('') /][/if]> list_res = new HashSet<[pojoName /][if (references->size() > 0)][getTDOLiteral('') /][/if]>();
			Integer groupIndex = null;
			String regex = null;
			String value = null;
			Pattern p = null;
			Matcher m = null;
			boolean matches = false;
			Row nestedRow = null;

			boolean addedInList = false;
			Row r1 = r;
			[pojoName /][if (references->size() > 0)][getTDOLiteral('') /][/if] [pojoName.toLowerFirst() /]1 = new [pojoName /][if (references->size() > 0)][getTDOLiteral('') /][/if]();
			[if (references->size() = 0)]
				[generateFlatMapBody(struct, entOrRel, pojoName, db, 1)/]
			[else]
				[generateFlatMapBodyTDOObject(struct, entOrRel, pojoName, db, 1, references)/]
			[/if]
			
			return list_res.iterator();

	}, Encoders.bean([pojoName /][if (references->size() > 0)][getTDOLiteral('') /][/if].class));
	res= res.dropDuplicates([if (attributes->size() > 0 and entOrRel.oclIsTypeOf(EntityType) and (entOrRel.oclAsType(EntityType).identifier.oclIsUndefined() = false))]new String['['/][']'/]{[for (attr : Attribute | attributes->any(true).ancestors(EntityType)->first().identifier.attributes) separator(',')]"[attr.name/]"[/for]}[/if]);
	return res;
[/template]

[template public generateBSONMatchQueryMethod(ent : EntityType, struct: AbstractPhysicalStructure, db : Database)]
[generateBSONMatchQueryMethod(ent.name.toUpperFirst(), ent.attributes, struct, db)/]
[/template]

[template public generateBSONMatchQueryMethod(rel : RelationshipType, struct: AbstractPhysicalStructure, db : Database)]
[generateBSONMatchQueryMethod(rel.name.toUpperFirst(), rel.attributes, struct, db)/]
[/template]


[template public generateBSONMatchQueryMethod(pojoName : String, attributes : Collection(Attribute), struct: AbstractPhysicalStructure, db : Database)]
public static Pair<List<String>, List<String>> getBSONUpdateQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](conditions.SetClause<[pojoName.toUpperFirst() /]Attribute> set) {
	List<String> res = new ArrayList<String>();
	Set<String> arrayFields = new HashSet<String>();
	if(set != null) {
		java.util.Map<String, java.util.Map<String, String>> longFieldValues = new java.util.HashMap<String, java.util.Map<String, String>>();
		java.util.Map<[pojoName.toUpperFirst() /]Attribute, Object> clause = set.getClause();
		for(java.util.Map.Entry<[pojoName.toUpperFirst() /]Attribute, Object> e : clause.entrySet()) {
			[pojoName.toUpperFirst() /]Attribute attr = e.getKey();
			Object value = e.getValue();
				[for (attr : Attribute | attributes)]
				[let field : PhysicalField = getMappedPhysicalField(attr, struct, db, struct.ancestors(Domainmodel)->first().mappingRules)][if (field <> null)]
			if(attr == [pojoName.toUpperFirst() /]Attribute.[attr.name /] ) {
					[if (field.ancestors(LongField) -> size() = 0)]
				String fieldName = "[getPhysicalName(field)/]";
						[for (parent : PhysicalField | field.ancestors(PhysicalField))]
							[if (parent.isArrayEmbeddedObject())]
				fieldName = "[parent.getPhysicalName()/].$['['/][getArrayFilterVariableName(parent.oclAsType(EmbeddedObject))/][']'/]." + fieldName;
				arrayFields.add("[getArrayFilterVariableName(parent.oclAsType(EmbeddedObject))/]");
							[else]
				fieldName = "[parent.getPhysicalName()/]." + fieldName;
							[/if]
						[/for]
				fieldName = "'" + fieldName + "'";
				res.add(fieldName + " : " + Util.getDelimitedMongoValue((value == null ? null : value.getClass()), (value == null ? null : value.toString())));
					[else]
				java.util.Map<String, String> longFieldValue = longFieldValues.get("[getPhysicalName(field.ancestors(LongField) -> first().oclAsType(LongField))/]");
				if(longFieldValue == null) {
					longFieldValue = new java.util.HashMap<String, String>();
					longFieldValues.put("[getPhysicalName(field.ancestors(LongField) -> first().oclAsType(LongField))/]", longFieldValue);
				}
				longFieldValue.put("[field.oclAsType(BracketsField).name/]", (value == null ? null : value.toString()));
					[/if]
			}
				[/if]
				[/let]
				[/for]			
		}

		for(java.util.Map.Entry<String, java.util.Map<String, String>> entry : longFieldValues.entrySet()) {
			String longField = entry.getKey();
			java.util.Map<String, String> values = entry.getValue();
			[for (lf : LongField | struct.getDescendentsLongField())]
			if(longField.equals("[getPhysicalName(lf)/]")) {
				String value;
				String v;
				[for (expr : TerminalExpression | lf.pattern)]
					[if (expr.oclIsTypeOf(pml::BracketsField))]
				v = values.get("[expr.oclAsType(BracketsField).name/]");
					[else]
				v = "[expr.literal/]";
					[/if]
				[if (i = 1)]
				value = v;
				[else]
				value += v;
				[/if]
				[/for]

				String fieldName = "[getPhysicalName(lf)/]";
				[for (parent : PhysicalField | lf.ancestors(PhysicalField))]
					[if (parent.isArrayEmbeddedObject())]
				fieldName = "[parent.getPhysicalName()/].$['['/][getArrayFilterVariableName(parent.oclAsType(EmbeddedObject))/][']'/]." + fieldName;
				arrayFields.add("[getArrayFilterVariableName(parent.oclAsType(EmbeddedObject))/]");
					[else]
				fieldName = "[parent.getPhysicalName()/]." + fieldName;
					[/if]
				[/for]
				fieldName = "'" + fieldName + "'";
				res.add(fieldName + " : " + Util.getDelimitedMongoValue((value == null ? null : value.getClass()), (value == null ? null : value.toString())));
			}
			[/for]
		}

	}
	return new ImmutablePair<List<String>, List<String>>(res, new ArrayList<String>(arrayFields));
}

public static String getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](Condition<[pojoName.toUpperFirst() /]Attribute> condition, MutableBoolean refilterFlag) {	
	String res = null;	
	if(condition != null) {
		if(condition instanceof SimpleCondition) {
			[pojoName /]Attribute attr = ((SimpleCondition<[pojoName /]Attribute>) condition).getAttribute();
			Operator op = ((SimpleCondition<[pojoName /]Attribute>) condition).getOperator();
			Object value = ((SimpleCondition<[pojoName /]Attribute>) condition).getValue();
			if(value != null) {
				String valueString = Util.transformBSONValue(value);
				boolean isConditionAttrEncountered = false;

				[for (attr : Attribute | attributes)]
				[let field : PhysicalField = getMappedPhysicalField(attr, struct, db, struct.ancestors(Domainmodel)->first().mappingRules)][if (field <> null)]
				if(attr == [pojoName.toUpperFirst() /]Attribute.[attr.name /] ) {
					isConditionAttrEncountered = true;
				[let ancestorsList : Sequence(EmbeddedObject) = field.ancestors(EmbeddedObject)]
				
				[if (field.ancestors(LongField) -> size() > 0)]
				String preparedValue = [getPreparedValue(attr, field, field.ancestors(LongField) -> first().oclAsType(LongField), false, false) /];
				boolean like_op = false;
				boolean not_like = false; 
				if(op == Operator.EQUALS && valueString != null && preparedValue.contains("[getPatternOtherValue() /]")) {
					//ex: @@VAR@@' '@@OTHERVAR@@"=> more than one vars in LongField: we shall use regex
					like_op = true;
					preparedValue = [getPreparedValue(attr, field, field.ancestors(LongField) -> first().oclAsType(LongField), false, true) /];
				} else {
					if(op == Operator.NOT_EQUALS && valueString != null && preparedValue.contains("[getPatternOtherValue() /]")) {
						//ex: @@VAR@@' '@@OTHERVAR@@"=> more than one vars in LongField: we shall use regex
						not_like = true;
						like_op = true;
						preparedValue = [getPreparedValue(attr, field, field.ancestors(LongField) -> first().oclAsType(LongField), false, true) /];
					}
				}
				if(op == Operator.CONTAINS && valueString != null) {
					like_op = true;
					preparedValue = [getPreparedValue(attr, field, field.ancestors(LongField) -> first().oclAsType(LongField), false, true) /];
					preparedValue = preparedValue.replaceAll("[getPatternValue() /]", ".*[getPatternValue() /].*");
				}
					
				if(like_op)
					valueString = Util.escapeReservedRegexMongo(valueString);
				preparedValue = preparedValue.replaceAll("[getPatternValue() /]", valueString).replaceAll("[getPatternOtherValue() /]", ".*");
				
				if(valueString.equals(preparedValue)) // 5 <=> 5, the preparedValue is the same type as the original value
					preparedValue = Util.getDelimitedMongoValue(value.getClass(), preparedValue);
				else // 5 => 5*, the preparedValue became a string
					preparedValue = Util.getDelimitedMongoValue(String.class, preparedValue);
					

				String mongoOp = (like_op) ? "$regex" : op.getMongoDBOperator();
				//if not_like = true then we need to complement/negate the given regex
				res = "[getPhysicalName(field)/]': {" + (!not_like ? (mongoOp + ": " + preparedValue) : ("$not: {" + mongoOp + ": " + preparedValue + "}")) + "}";
				[else]
					String mongoOp = op.getMongoDBOperator();
					String preparedValue = valueString;
					if(op == Operator.CONTAINS && valueString != null) {
						preparedValue = "'.*" + Util.escapeReservedRegexMongo(valueString)  + ".*'";
					} else {
						preparedValue = Util.getDelimitedMongoValue(value.getClass(), preparedValue);
					}
					res = "[getPhysicalName(field) /]': {" + mongoOp + ": " + [if (attr.type.oclIsTypeOf(pml::DateType))] "ISODate("+preparedValue + ")}";[else]preparedValue + "}";[/if]
				[/if]

				[if (ancestorsList->size() > 0)]
				[comment level-n field, with n > 1 /]
				[for (ancestor : EmbeddedObject | ancestorsList)]
					res = "[ancestor.name /]." + res;
				[/for]
				[/if]
				res = "'" + res;
				[/let]
				}
				[/if]
				[/let]
				[/for]
				if(!isConditionAttrEncountered) {
					refilterFlag.setValue(true);
					res = "$expr: {$eq:[ '[' /]1,1[ ']' /]}";
				}
				
			}
		}

		if(condition instanceof AndCondition) {
			String bsonLeft = getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](((AndCondition)condition).getLeftCondition(), refilterFlag);
			String bsonRight = getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](((AndCondition)condition).getRightCondition(), refilterFlag);			
			if(bsonLeft == null && bsonRight == null)
				return null;
			if(bsonLeft == null)
				return bsonRight;
			if(bsonRight == null)
				return bsonLeft;
			res = " $and: [ '[' /] {" + bsonLeft + "}, {" + bsonRight + "}[ ']' /] ";
		}

		if(condition instanceof OrCondition) {
			String bsonLeft = getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](((OrCondition)condition).getLeftCondition(), refilterFlag);
			String bsonRight = getBSONMatchQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](((OrCondition)condition).getRightCondition(), refilterFlag);			
			if(bsonLeft == null && bsonRight == null)
				return null;
			if(bsonLeft == null)
				return bsonRight;
			if(bsonRight == null)
				return bsonLeft;
			res = " $or: [ '[' /] {" + bsonLeft + "}, {" + bsonRight + "}[ ']' /] ";	
		}

		

		
	}

	return res;
}

public static Pair<String, List<String>> getBSONQueryAndArrayFilterForUpdateQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](Condition<[pojoName.toUpperFirst() /]Attribute> condition, final List<String> arrayVariableNames, Set<String> arrayVariablesUsed, MutableBoolean refilterFlag) {	
	String query = null;
	List<String> arrayFilters = new ArrayList<String>();
	if(condition != null) {
		if(condition instanceof SimpleCondition) {
			String bson = null;
			[pojoName /]Attribute attr = ((SimpleCondition<[pojoName /]Attribute>) condition).getAttribute();
			Operator op = ((SimpleCondition<[pojoName /]Attribute>) condition).getOperator();
			Object value = ((SimpleCondition<[pojoName /]Attribute>) condition).getValue();
			if(value != null) {
				String valueString = Util.transformBSONValue(value);
				boolean isConditionAttrEncountered = false;

				[for (attr : Attribute | attributes)]
				[let field : PhysicalField = getMappedPhysicalField(attr, struct, db, struct.ancestors(Domainmodel)->first().mappingRules)][if (field <> null)]
				if(attr == [pojoName.toUpperFirst() /]Attribute.[attr.name /] ) {
					isConditionAttrEncountered = true;
				[if (field.ancestors(LongField) -> size() > 0)]
				String preparedValue = [getPreparedValue(attr, field, field.ancestors(LongField) -> first().oclAsType(LongField), false, false) /];
				boolean like_op = false;
				boolean not_like = false; 
				if(op == Operator.EQUALS && valueString != null && preparedValue.contains("[getPatternOtherValue() /]")) {
					//ex: @@VAR@@' '@@OTHERVAR@@"=> more than one vars in LongField: we shall use regex
					like_op = true;
					preparedValue = [getPreparedValue(attr, field, field.ancestors(LongField) -> first().oclAsType(LongField), false, true) /];
				} else {
					if(op == Operator.NOT_EQUALS && valueString != null && preparedValue.contains("[getPatternOtherValue() /]")) {
						//ex: @@VAR@@' '@@OTHERVAR@@"=> more than one vars in LongField: we shall use regex
						not_like = true;
						like_op = true;
						preparedValue = [getPreparedValue(attr, field, field.ancestors(LongField) -> first().oclAsType(LongField), false, true) /];
					}
				}
				if(op == Operator.CONTAINS && valueString != null) {
					like_op = true;
					preparedValue = [getPreparedValue(attr, field, field.ancestors(LongField) -> first().oclAsType(LongField), false, true) /];
					preparedValue = preparedValue.replaceAll("[getPatternValue() /]", ".*[getPatternValue() /].*");
				}
					
				if(like_op)
					valueString = Util.escapeReservedRegexMongo(valueString);
				preparedValue = preparedValue.replaceAll("[getPatternValue() /]", valueString).replaceAll("[getPatternOtherValue() /]", ".*");
				
				if(valueString.equals(preparedValue)) // 5 <=> 5, the preparedValue is the same type as the original value
					preparedValue = Util.getDelimitedMongoValue(value.getClass(), preparedValue);
				else // 5 => 5*, the preparedValue became a string
					preparedValue = Util.getDelimitedMongoValue(String.class, preparedValue);
					

				String mongoOp = (like_op) ? "$regex" : op.getMongoDBOperator();
				//if not_like = true then we need to complement/negate the given regex
				bson = "[getPhysicalName(field)/]': {" + (!not_like ? (mongoOp + ": " + preparedValue) : ("$not: {" + mongoOp + ": " + preparedValue + "}")) + "}";
				[else]
					String mongoOp = op.getMongoDBOperator();
					String preparedValue = valueString;
					if(op == Operator.CONTAINS && valueString != null) {
						preparedValue = "'.*" + Util.escapeReservedRegexMongo(valueString)  + ".*'";
					} else {
						preparedValue = Util.getDelimitedMongoValue(value.getClass(), preparedValue);
					}
					bson = "[getPhysicalName(field) /]': {" + mongoOp + ": " + preparedValue + "}";
				[/if]
				
					boolean arrayVar = false;
					[for (parent : PhysicalField | getStartField(field).ancestors(PhysicalField))]
					if(!arrayVar) {
						[if (parent.isArrayEmbeddedObject())]
						if(arrayVariableNames.contains("[getArrayFilterVariableName(parent.oclAsType(EmbeddedObject))/]")) {
							arrayVar = true;
							arrayVariablesUsed.add("[getArrayFilterVariableName(parent.oclAsType(EmbeddedObject))/]");
							bson = "[getArrayFilterVariableName(parent.oclAsType(EmbeddedObject))/]." + bson; 
						} else {
							bson = "[parent.getPhysicalName()/]." + bson;
						}
						[else]
						bson = "[parent.getPhysicalName()/]." + bson;
						[/if]
					}
					[/for]

					bson = "'" + bson;
					if(arrayVar)
						arrayFilters.add(bson);
					else
						query = bson;
				}
				[/if]
				[/let]
				[/for]
				if(!isConditionAttrEncountered) {
					refilterFlag.setValue(true);
				}
				
			}

		}

		if(condition instanceof AndCondition) {
			Pair<String, List<String>> bsonLeft = getBSONQueryAndArrayFilterForUpdateQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](((AndCondition)condition).getLeftCondition(), arrayVariableNames, arrayVariablesUsed, refilterFlag);
			Pair<String, List<String>> bsonRight = getBSONQueryAndArrayFilterForUpdateQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](((AndCondition)condition).getRightCondition(), arrayVariableNames, arrayVariablesUsed, refilterFlag);			
			
			String queryLeft = bsonLeft.getLeft();
			String queryRight = bsonRight.getLeft();
			List<String> arrayFilterLeft = bsonLeft.getRight();
			List<String> arrayFilterRight = bsonRight.getRight();

			if(queryLeft == null && queryRight != null)
				query = queryRight;
			if(queryLeft != null && queryRight == null)
				query = queryLeft;
			if(queryLeft != null && queryRight != null)
				query = " $and: [ '[' /] {" + queryLeft + "}, {" + queryRight + "}[ ']' /] ";

			arrayFilters.addAll(arrayFilterLeft);
			arrayFilters.addAll(arrayFilterRight);
		}

		if(condition instanceof OrCondition) {
			Pair<String, List<String>> bsonLeft = getBSONQueryAndArrayFilterForUpdateQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](((AndCondition)condition).getLeftCondition(), arrayVariableNames, arrayVariablesUsed, refilterFlag);
			Pair<String, List<String>> bsonRight = getBSONQueryAndArrayFilterForUpdateQueryIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](((AndCondition)condition).getRightCondition(), arrayVariableNames, arrayVariablesUsed, refilterFlag);			
			
			String queryLeft = bsonLeft.getLeft();
			String queryRight = bsonRight.getLeft();
			List<String> arrayFilterLeft = bsonLeft.getRight();
			List<String> arrayFilterRight = bsonRight.getRight();

			if(queryLeft == null && queryRight != null)
				query = queryRight;
			if(queryLeft != null && queryRight == null)
				query = queryLeft;
			if(queryLeft != null && queryRight != null)
				query = " $or: [ '[' /] {" + queryLeft + "}, {" + queryRight + "}[ ']' /] ";

			arrayFilters.addAll(arrayFilterLeft);
			arrayFilters.addAll(arrayFilterRight); // can be a problem
		}
	}

	return new ImmutablePair<String, List<String>>(query, arrayFilters);
}


[/template]



[template private generateHybridFlatMapBody(arg : OclAny, rel: RelationshipType, db : Database, level : Integer)]
boolean toAdd[level /]  = false;
WrappedArray array[level /]  = null;
[for (child : PhysicalField | getChildrenNonArrayPhysicalFields(arg))]
[if (rel.attributes->notEmpty())]
	[for (mapAttr : Attribute | getMappedAttributes(child, rel, db.ancestors(Domainmodel)->first().mappingRules))]
// Field '[child.getPhysicalName()/]' is mapped to '[mapAttr.name/]' attribute of rel '[rel.name/]' 
if(nestedRow != null && Arrays.asList(nestedRow.schema().fieldNames()).contains("[getPhysicalName(child)/]")) {
	[if (child.ancestors(LongField) -> size() = 0)]
	[comment shortField or bracketfield/]
	if(nestedRow.getAs("[getPhysicalName(child)/]")==null)
		[rel.name.toLowerFirst() /][level/].set[mapAttr.name.toUpperFirst() /](null);
	else{
		[rel.name.toLowerFirst() /][level/].set[mapAttr.name.toUpperFirst() /](Util.get[generateJavaTypeMethodNameCompliant(mapAttr.type) /]Value(nestedRow.getAs("[getPhysicalName(child)/]")));
		toAdd[level/] = true;					
		}
	[else]
		[if (child.ancestors(LongField) -> first().oclAsType(LongField).pattern->size() = 1)][comment if you encounter a "short" long field. E.g., rate: rating  /]
	if(nestedRow.getAs("[getPhysicalName(child.ancestors(LongField) -> first().oclAsType(LongField)) /]")==null)
		[rel.name.toLowerFirst() /][level/].set[mapAttr.name.toUpperFirst() /](null)
	else{
		[rel.name.toLowerFirst() /][level/].set[mapAttr.name.toUpperFirst() /](Util.get[generateJavaTypeMethodNameCompliant(mapAttr.type) /]Value(nestedRow.getAs("[getPhysicalName(child.ancestors(LongField) -> first().oclAsType(LongField)) /]")));
		toAdd[level/] = true;	
		}
		[else]
	throw new UnsupportedOperationException("Get of relationship type attributes longField not implemented yet.");
		[/if]
	[/if]
	}
	[/for]
[/if]
[let mappedAttrList : Collection(Attribute) = getMappedAttributesFromMultipleEntityTypes(child, rel.roles -> collect(role : Role | role.entity)->asSet(), db.ancestors(Domainmodel)->first().mappingRules)]
[if (mappedAttrList->size() > 0)]
[for (attr : Attribute | mappedAttrList)]
[let entity : EntityType = attr.ancestors(EntityType) -> any(true)]
[let ancestorsList : Sequence(EmbeddedObject) = getSequenceOfNonArrayEmbeddedObjects(child)]
// 	attribute [entity.name /].[attr.name /] for field [getPhysicalName(child) /]			
nestedRow =  r[level /];
[for (anc : EmbeddedObject | ancestorsList->reverse())]
[comment simple row /]
nestedRow = (nestedRow == null) ? null : (Row) nestedRow.getAs("[getPhysicalName(anc)/]");
[/for]
[/let]
if(nestedRow != null && Arrays.asList(nestedRow.schema().fieldNames()).contains("[getPhysicalName(child)/]")) {
	[if (child.ancestors(LongField) -> size() = 0)]
	[comment shortField or bracketfield/]
	if(nestedRow.getAs("[getPhysicalName(child)/]")==null)
		[rel.name.toLowerFirst() /][level/].get[rel.roles->select(role : Role | role.entity = entity )->any(true).name.toUpperFirst() /]().set[attr.name.toUpperFirst() /](null);
	else{
		[rel.name.toLowerFirst() /][level/].get[rel.roles->select(role : Role | role.entity = entity )->any(true).name.toUpperFirst() /]().set[attr.name.toUpperFirst() /](Util.get[generateJavaTypeMethodNameCompliant(attr.type) /]Value(nestedRow.getAs("[getPhysicalName(child)/]")));
		toAdd[level/] = true;					
		}
	[else]
		[if (child.ancestors(LongField) -> first().oclAsType(LongField).pattern->size() = 1)][comment if you encounter a "short" long field. E.g., rate: rating  /]
	if(nestedRow.getAs("[getPhysicalName(child.ancestors(LongField) -> first().oclAsType(LongField)) /]")==null)
		[rel.name.toLowerFirst() /][level/].get[rel.roles->select(role : Role | role.entity = entity )->any(true).name.toUpperFirst() /]().set[attr.name.toUpperFirst() /](null)
	else{
		[rel.name.toLowerFirst() /][level/].get[rel.roles->select(role : Role | role.entity = entity )->any(true).name.toUpperFirst() /]().set[attr.name.toUpperFirst() /](Util.get[generateJavaTypeMethodNameCompliant(attr.type) /]Value(nestedRow.getAs("[getPhysicalName(child.ancestors(LongField) -> first().oclAsType(LongField)) /]")));
		toAdd[level/] = true;	
		}
		[else]
	[comment LongField /]
	regex = "[getJavaRegexFromLongField(child.ancestors(LongField) -> first().oclAsType(LongField)) /]";
	groupIndex = [getPositionInLongField(child, child.ancestors(LongField) -> first().oclAsType(LongField))/];
	if(groupIndex == null) {
		throw new Exception("Cannot retrieve value for [entity.name /].[attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
	}
	value = nestedRow.getAs("[child.ancestors(LongField) -> first().oclAsType(LongField).physicalName /]");
	p = Pattern.compile(regex);
	m = p.matcher(value);
	matches = m.find();
	if(matches) {
		String [attr.name.toLowerFirst()/] = m.group(groupIndex.intValue());
		[rel.name.toLowerFirst() /][level/].get[rel.roles->select(role : Role | role.entity = entity )->any(true).name.toUpperFirst() /]().set[attr.name.toUpperFirst()/]([generateParsingFunctionJavaType(attr.type, attr.name.toLowerFirst())/]);
		toAdd[level/] = true;
	} else {
		throw new Exception("Cannot retrieve value for [entity.name /].[attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
	}
		[/if]
	[/if]
}
[/let]
[/for]
[/if]
[/let]
[/for]
[let children : Collection(EmbeddedObject) = getChildrenArrayPhysicalFieldsHavingDescendantMappedToGivenEntityTypes(arg, rel.roles -> collect(role : Role | role.entity)->asSet(), rel.ancestors(Domainmodel)->first().mappingRules)]
[if (children->size() > 0)]
[for (child : EmbeddedObject | children)]
array[level /] = r[level /].getAs("[getPhysicalName(child)/]");
if(array[level /]!= null) {
	for (int i[level + 1/] = 0; i[level + 1/] < array[level /].size(); i[level + 1/]++){
		Row r[level + 1 /] = (Row) array[level /].apply(i[level + 1/]);
		[rel.name.toUpperFirst() /] [rel.name.toLowerFirst() /][level + 1/] = ([rel.name.toUpperFirst() /]) [rel.name.toLowerFirst() /][level/].clone();
		[generateHybridFlatMapBody(child, rel, db, level + 1)/]
	}
}

if(toAdd[level /] [if (level > 1)]&& ([for (role : Role | rel.roles) separator('&&')]([role.name/]_condition == null || [role.name/]_refilter.booleanValue() || [role.name/]_condition.evaluate([rel.name.toLowerFirst() /][level /].get[role.name.toUpperFirst()/]()))[/for])[/if]) {
	if(!([for (role : Role | rel.roles) separator(') && !(')][rel.name.toLowerFirst() /][level /].get[role.name.toUpperFirst()/]().equals(new [role.entity.name.toUpperFirst()/]())[/for]))
		list_res.add([rel.name.toLowerFirst() /][level /]);
	addedInList = true;
} 
[if (level > 1)]if(addedInList)
	toAdd[level - 1 /] = false;[/if]

[/for]
[else]
if(toAdd[level /] [if (level > 1)]&& ([for (role : Role | rel.roles) separator('&&')]([role.name/]_condition == null || [role.name/]_refilter.booleanValue() || [role.name/]_condition.evaluate([rel.name.toLowerFirst() /][level /].get[role.name.toUpperFirst()/]()))[/for])[/if]) {
	if(!([for (role : Role | rel.roles) separator(') && !(')][rel.name.toLowerFirst() /][level /].get[role.name.toUpperFirst()/]().equals(new [role.entity.name.toUpperFirst()/]())[/for]))
		list_res.add([rel.name.toLowerFirst() /][level /]);
	addedInList = true;
} 
[if (level > 1)]if(addedInList)
	toAdd[level - 1 /] = false;[/if]
[/if]
[/let]
[/template]


[template private generateFlatMapBody(arg : OclAny, entOrRel : OclAny, pojoName : String, db : Database, level : Integer)]
boolean toAdd[level /]  = false;
WrappedArray array[level /]  = null;
[for (child : PhysicalField | getChildrenNonArrayPhysicalFields(arg))]
[let mappedAttrList : Collection(Attribute) = getMappedAttributes(child, entOrRel, db.ancestors(Domainmodel)->first().mappingRules)]
[if (mappedAttrList->size() > 0)]
[for (attr : Attribute | mappedAttrList)]
[let ancestorsList : Sequence(EmbeddedObject) = getSequenceOfNonArrayEmbeddedObjects(child)]
// 	attribute [pojoName /].[attr.name /] for field [getPhysicalName(child) /]			
nestedRow =  r[level /];
[for (anc : EmbeddedObject | ancestorsList->reverse())]
[comment simple row /]
nestedRow = (nestedRow == null) ? null : (Row) nestedRow.getAs("[getPhysicalName(anc)/]");
[/for]
[/let]
if(nestedRow != null && Arrays.asList(nestedRow.schema().fieldNames()).contains("[getPhysicalName(child)/]")) {
	[if (child.ancestors(LongField) -> size() = 0)]
	[comment shortField or bracketfield/]
	if(nestedRow.getAs("[getPhysicalName(child)/]")==null)
		[pojoName.toLowerFirst() /][level/].set[attr.name.toUpperFirst() /](null);
	else{
		[pojoName.toLowerFirst() /][level/].set[attr.name.toUpperFirst() /](Util.get[generateJavaTypeMethodNameCompliant(attr.type) /]Value(nestedRow.getAs("[getPhysicalName(child) /]")));
		toAdd[level/] = true;					
		}
	[else]
		[if (child.ancestors(LongField) -> first().oclAsType(LongField).pattern->size() = 1)][comment if you encounter a "short" long field. E.g., rate: rating  /]
	if(nestedRow.getAs("[getPhysicalName(child.ancestors(LongField) -> first().oclAsType(LongField)) /]")==null)
		[pojoName.toLowerFirst() /][level/].set[attr.name.toUpperFirst() /](null);
	else{
		if(Arrays.asList(nestedRow.schema().fieldNames()).contains("[getPhysicalName(child.ancestors(LongField) -> first().oclAsType(LongField)) /]")){
			[pojoName.toLowerFirst() /][level/].set[attr.name.toUpperFirst() /](Util.get[generateJavaTypeMethodNameCompliant(attr.type) /]Value(nestedRow.getAs("[getPhysicalName(child.ancestors(LongField) -> first().oclAsType(LongField)) /]")));
			toAdd[level/] = true;	
			}
		}
		[else]
	[comment LongField /]
	regex = "[getJavaRegexFromLongField(child.ancestors(LongField) -> first().oclAsType(LongField)) /]";
	groupIndex = [getPositionInLongField(child, child.ancestors(LongField) -> first().oclAsType(LongField))/];
	if(groupIndex == null) {
		throw new Exception("Cannot retrieve value for [pojoName /].[attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
	}
	value = nestedRow.getAs("[child.ancestors(LongField) -> first().oclAsType(LongField).physicalName /]");
	p = Pattern.compile(regex);
	m = p.matcher(value);
	matches = m.find();
	if(matches) {
		String [attr.name.toLowerFirst()/] = m.group(groupIndex.intValue());
		[pojoName.toLowerFirst() /][level/].set[attr.name.toUpperFirst()/]([generateParsingFunctionJavaType(attr.type, attr.name.toLowerFirst())/]);
		toAdd[level/] = true;
	} else {
		throw new Exception("Cannot retrieve value for [pojoName /].[attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
	}
		[/if]
	[/if]
}
[/for]
[/if]
[/let]
[/for]
[let children : Collection(EmbeddedObject) = getChildrenArrayPhysicalFieldsHavingDescendantMappedToGivenEntityType(arg, entOrRel, entOrRel.ancestors(Domainmodel)->first().mappingRules)]
[if (children->size() > 0)]
[for (child : EmbeddedObject | children)]
array[level /] = r[level /].getAs("[getPhysicalName(child)/]");
if(array[level /]!= null) {
	for (int i[level + 1/] = 0; i[level + 1/] < array[level /].size(); i[level + 1/]++){
		Row r[level + 1 /] = (Row) array[level /].apply(i[level + 1/]);
		[pojoName /] [pojoName.toLowerFirst() /][level + 1/] = ([pojoName /]) [pojoName.toLowerFirst() /][level/].clone();
		[generateFlatMapBody(child, entOrRel, pojoName, db, level + 1)/]
	}
}

if(toAdd[level /][if (level > 1)]&& (condition == null || refilterFlag.booleanValue() || condition.evaluate([pojoName.toLowerFirst() /][level /]))[/if]) {
	list_res.add([pojoName.toLowerFirst() /][level /]);
	addedInList = true;
} 
[if (level > 1)]if(addedInList)
	toAdd[level - 1 /] = false;[/if]

[/for]
[else]
if(toAdd[level /][if (level > 1)]&& (condition ==null || refilterFlag.booleanValue() || condition.evaluate([pojoName.toLowerFirst() /][level /]))[/if]) {
	list_res.add([pojoName.toLowerFirst() /][level /]);
	addedInList = true;
} 
[if (level > 1)]if(addedInList)
	toAdd[level - 1 /] = false;[/if]
[/if]
[/let]
[/template]

[template private generateFlatMapBodyTDOObject(arg : OclAny, entOrRel : OclAny, pojoName : String, db : Database, level : Integer, references : Sequence(Sequence(OclAny)))]
boolean toAdd[level /]  = false;
WrappedArray array[level /]  = null;
[for (child : PhysicalField | getChildrenNonArrayPhysicalFields(arg))]
[let mappedAttrList : Collection(Attribute) = getMappedAttributes(child, entOrRel, entOrRel.ancestors(Domainmodel)->first().mappingRules)]
[if (mappedAttrList->size() > 0)]
[for (attr : Attribute | mappedAttrList)]
[let ancestorsList : Sequence(EmbeddedObject) = getSequenceOfNonArrayEmbeddedObjects(child)]
// 	attribute [pojoName /].[attr.name /] for field [getPhysicalName(child) /]			
nestedRow =  r[level /];
[for (anc : EmbeddedObject | ancestorsList->reverse())]
[comment simple row /]
nestedRow = (nestedRow == null) ? null : (Row) nestedRow.getAs("[getPhysicalName(anc)/]");
[/for]
[/let]
if(nestedRow != null && Arrays.asList(nestedRow.schema().fieldNames()).contains("[getPhysicalName(child) /]")) {
	[if (child.ancestors(LongField) -> size() = 0)]
	[comment shortField or bracketfield/]
	if(nestedRow.getAs("[getPhysicalName(child)/]") == null){
		[pojoName.toLowerFirst() /][level/].set[attr.name.toUpperFirst() /](null);
	}else{
		[pojoName.toLowerFirst() /][level/].set[attr.name.toUpperFirst() /](Util.get[generateJavaTypeMethodNameCompliant(attr.type) /]Value(nestedRow.getAs("[getPhysicalName(child) /]")));
		toAdd[level/] = true;					
		}
	[else]
		[if (child.ancestors(LongField) -> first().oclAsType(LongField).pattern->size() = 1)][comment if you encounter a "short" long field. E.g., rate: rating  /]
	if(nestedRow.getAs("[getPhysicalName(child.ancestors(LongField) -> first().oclAsType(LongField)) /]")==null)
		[pojoName.toLowerFirst() /][level/].set[attr.name.toUpperFirst() /](null);
	else{
		[pojoName.toLowerFirst() /][level/].set[attr.name.toUpperFirst() /](Util.get[generateJavaTypeMethodNameCompliant(attr.type) /]Value(nestedRow.getAs("[getPhysicalName(child.ancestors(LongField) -> first().oclAsType(LongField)) /]")));
		toAdd[level/] = true;	
	}
		[else]
	[comment LongField /]
	regex = "[getJavaRegexFromLongField(child.ancestors(LongField) -> first().oclAsType(LongField)) /]";
	groupIndex = [getPositionInLongField(child, child.ancestors(LongField) -> first().oclAsType(LongField))/];
	if(groupIndex == null) {
		throw new Exception("Cannot retrieve value for [pojoName/].[attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
	}
	value = nestedRow.getAs("[child.ancestors(LongField) -> first().oclAsType(LongField).physicalName /]");
	p = Pattern.compile(regex);
	m = p.matcher(value);
	matches = m.find();
	if(matches) {
		String [attr.name.toLowerFirst()/] = m.group(groupIndex.intValue());
		[pojoName.toLowerFirst() /][level/].set[attr.name.toUpperFirst()/]([generateParsingFunctionJavaType(attr.type, attr.name.toLowerFirst())/]);
		toAdd[level/] = true;
	} else {
		throw new Exception("Cannot retrieve value for [pojoName /].[attr.name /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
	}
		[/if]
	[/if]
}
[/for]
[/if]
[/let]
[/for]

[for (pair : Sequence(OclAny) | references)]
[let ref : Reference = pair->at(1)]
[let refFields : Sequence(PhysicalField) = pair->at(2)]
[for (refField : PhysicalField | refFields)]
[comment Ici r�it�rer sur 'child' et v�fifier ce n'est aps le refField Si oui appliquer comme au dessus /]
[for (child : PhysicalField | getChildrenNonArrayPhysicalFields(arg))]
[if (child = refField)]
	// field  [getPhysicalName(child) /] for reference [ref.name/] . Reference field : [getPhysicalName(refField)/]
[let ancestorsList : Sequence(EmbeddedObject) = getSequenceOfNonArrayEmbeddedObjects(child)]
nestedRow =  r[level /];
[for (anc : EmbeddedObject | ancestorsList->reverse())]
[comment simple row /]
nestedRow = (nestedRow == null) ? null : (Row) nestedRow.getAs("[getPhysicalName(anc)/]");
[/for]
[/let]
if(nestedRow != null) {
	[if (child.ancestors(LongField) -> size() = 0)]
		[if (child.oclIsTypeOf(ArrayField))]
	// Reference is in an Array Field
	[pojoName.toLowerFirst() /][level/].set[getJavaAbsolutePath(ref, refField).toUpperFirst() /](nestedRow.getAs("[refField.getPhysicalName() /]") == null ? null : new ArrayList<String>(ScalaUtil.javaList(nestedRow.getAs("[refField.getPhysicalName() /]"))));
		[else]
			[if (child.ancestors(EmbeddedObject)->size() > 0)]
	// Reference is in an Array of Embedded Objects
	[pojoName.toLowerFirst() /][level/].get[getJavaAbsolutePath(ref, refField).toUpperFirst() /]().add(nestedRow.getAs("[refField.getPhysicalName() /]") == null ? null : nestedRow.getAs("[refField.getPhysicalName() /]").toString());
			[else]
	[pojoName.toLowerFirst() /][level/].set[getJavaAbsolutePath(ref, refField).toUpperFirst() /](nestedRow.getAs("[refField.getPhysicalName() /]") == null ? null : nestedRow.getAs("[refField.getPhysicalName() /]").toString());
			[/if]
		[/if]
	[comment shortField or bracketfield/]
	toAdd[level/] = true;					
	[else]
		[if (child.ancestors(LongField) -> first().oclAsType(LongField).pattern->size() = 1)][comment if you encounter a "short" long field. E.g., rate: rating  /]
	[pojoName.toLowerFirst() /][level/].set[getJavaAbsolutePath(ref, refField).toUpperFirst() /]((String) nestedRow.getAs("[getPhysicalName(child.ancestors(LongField) -> first().oclAsType(LongField)) /]"));
	toAdd[level/] = true;	
		[else]
	[comment LongField /]
	regex = "[getJavaRegexFromLongField(child.ancestors(LongField) -> first().oclAsType(LongField)) /]";
	groupIndex = [getPositionInLongField(child, child.ancestors(LongField) -> first().oclAsType(LongField))/];
	if(groupIndex == null) {
		logger.warn("Cannot retrieve value for [pojoName /][refField.getPhysicalName() /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
		throw new Exception("Cannot retrieve value for [pojoName /][refField.getPhysicalName() /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
	}
	value = nestedRow.getAs("[child.ancestors(LongField) -> first().oclAsType(LongField).physicalName /]");
	p = Pattern.compile(regex);
	m = p.matcher(value);
	matches = m.find();
	if(matches) {
		String [getJavaAbsolutePath(ref, refField) /] = m.group(groupIndex.intValue());
		[pojoName.toLowerFirst() /][level/].set[getJavaAbsolutePath(ref, refField).toUpperFirst() /]([getJavaAbsolutePath(ref, refField) /]);
		toAdd[level/] = true;
	} else {
		logger.warn("Cannot retrieve value for [pojoName /][refField.getPhysicalName() /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
		throw new Exception("Cannot retrieve value for [pojoName /][refField.getPhysicalName() /] attribute stored in db [db.name/]. Probably due to an ambiguous regex.");
	}
		[/if]
	[/if]
}
[/if]
[/for]
[/for]
[/let]
[/let]
[/for]

[comment  /]

[comment Ici modifier �galement afin d'aller voir dans les multi value complex object si l'objet refField n'y est pas./]
[for (pair : Sequence(OclAny) | references)]
	[let ref : Reference = pair->at(1)]
	[let refFields : Sequence(PhysicalField) = pair->at(2)]
	[let children : Collection(PhysicalField) = getChildrenArrayPhysicalFieldsHavingDescendantMappedToGivenEntityTypeOrToRefField(arg, entOrRel, entOrRel.ancestors(Domainmodel)->first().mappingRules, refFields)]
	[if (children->size() > 0)]
		[for (child : PhysicalField | children)]
array[level /] = r[level /].getAs("[getPhysicalName(child)/]");
if(array[level /]!= null) {
	for (int i[level + 1/] = 0; i[level + 1/] < array[level /].size(); i[level + 1/]++){
		Row r[level + 1 /] = (Row) array[level /].apply(i[level + 1/]);
		[pojoName /][getTDOLiteral(ref) /] [pojoName.toLowerFirst() /][level + 1/] = ([pojoName /][getTDOLiteral(ref) /]) [pojoName.toLowerFirst() /][level/].clone();
		[generateFlatMapBodyTDOObject(child, entOrRel,pojoName, db, level + 1, Sequence{Sequence{ref, refFields}})/]
	}
}

if(toAdd[level /][if (level > 1)]&&((condition == null || refilterFlag.booleanValue() || condition.evaluate([pojoName.toLowerFirst() /][level /])))[/if]) {
	list_res.add([pojoName.toLowerFirst() /][level /]);
	addedInList = true;
} 
			[if (level > 1)]
if(addedInList)
	toAdd[level - 1 /] = false;
			[/if]
		[/for]
	[else]
if(toAdd[level /][if (level > 1)]&&((condition ==null || refilterFlag.booleanValue() || condition.evaluate([pojoName.toLowerFirst() /][level /])))[/if]) {
	list_res.add([pojoName.toLowerFirst() /][level /]);
	addedInList = true;
} 
		[if (level > 1)]
if(addedInList)
	toAdd[level - 1 /] = false;
		[/if]
	[/if]
	[/let]
	[/let]
	[/let]
[/for]

[/template]

[query private getChildrenNonArrayPhysicalFields(arg : OclAny) : Collection(PhysicalField) =  
	invoke('be.unamur.polystore.acceleo.main.utils.Util', 'getChildrenNonArrayPhysicalFields(java.lang.Object)', Sequence{arg})
/]

[query public getMappedAttributesFromMultipleEntityTypes(field : PhysicalField, entities : Set(EntityType), rules : MappingRules) :  Collection(Attribute) = 
entities->collect(entity : EntityType | getMappedAttributes(field, entity, rules))->flatten()/]


[query private getMappedAttributes(field: PhysicalField, entOrRel: OclAny, rules: MappingRules) : Collection(Attribute) =  
	invoke('be.unamur.polystore.acceleo.main.utils.Util', 'getMappedAttributes(be.unamur.polystore.pml.PhysicalField, java.lang.Object, be.unamur.polystore.pml.MappingRules)', Sequence{field, entOrRel, rules})
/]

[query private getChildrenArrayPhysicalFieldsHavingDescendantMappedToGivenEntityType(arg : OclAny, entOrRel: OclAny, rules: MappingRules) : Collection(EmbeddedObject) =  
	invoke('be.unamur.polystore.acceleo.main.utils.Util', 'getChildrenArrayPhysicalFieldsHavingDescendantMappedToGivenEntityType(java.lang.Object, java.lang.Object, be.unamur.polystore.pml.MappingRules)', Sequence{arg, entOrRel, rules})
/]

[query private getChildrenArrayPhysicalFieldsHavingDescendantMappedToGivenEntityTypes(arg : OclAny, entities: Set(EntityType), rules: MappingRules) : Collection(EmbeddedObject) = 
entities->collect(entity : EntityType | getChildrenArrayPhysicalFieldsHavingDescendantMappedToGivenEntityType(arg, entity, rules))->flatten()/]


[query private getChildrenArrayPhysicalFieldsHavingDescendantMappedToGivenEntityTypeOrToRefField(arg : OclAny, entOrRel: OclAny, rules: MappingRules, refFields: Collection(PhysicalField)) : Collection(EmbeddedObject) =  
	invoke('be.unamur.polystore.acceleo.main.utils.Util', 'getChildrenArrayPhysicalFieldsHavingDescendantMappedToGivenEntityTypeOrToRefField(java.lang.Object, java.lang.Object, be.unamur.polystore.pml.MappingRules, java.util.List)', Sequence{arg, entOrRel, rules, refFields})
/]

[query private getSequenceOfNonArrayEmbeddedObjects(field : OclAny) : Sequence(EmbeddedObject) =  
	invoke('be.unamur.polystore.acceleo.main.utils.Util', 'getSequenceOfNonArrayEmbeddedObjects(org.eclipse.emf.ecore.EObject)', Sequence{field})
/]

[template private getArrayFilterVariableName(array : EmbeddedObject)]
[if (array.oclIsUndefined() = false)][getArrayFilterVariableName(array.eContainer(EmbeddedObject))/][array.name /]0[/if]
[/template]


[template public getTDOLiteral(o : OclAny)][if (o.oclIsUndefined() = false)]TDO[/if][/template]

[query private getStartField(field : PhysicalField) : PhysicalField = 
invoke('be.unamur.polystore.acceleo.main.utils.Util', 'getStartField(be.unamur.polystore.pml.PhysicalField)', Sequence{field})
/]


