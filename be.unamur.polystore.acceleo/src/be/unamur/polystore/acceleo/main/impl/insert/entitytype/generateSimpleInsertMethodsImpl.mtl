[comment encoding = UTF-8 /]
[module generateSimpleInsertMethodsImpl('http://www.unamur.be/polystore/Pml')]
[import be::unamur::polystore::acceleo::main::mappingrules::util /]
[import be::unamur::polystore::acceleo::main::util /]

[template public insertPOJOInRImpl(entityType: EntityType, roles : Collection(Role), conceptualSchema: ConceptualSchema)]{
	boolean inserted = false;
	// Insert in standalone structures
	[for (struct: AbstractPhysicalStructure | getMappedPhysicalStructureToInsertSingleE(entityType, entityType.ancestors(Domainmodel)->first()))]
	[for (db: Database | getConcernedDatabases(struct, entityType.ancestors(Domainmodel)->first()))]
	inserted = insert[entityType.name.toUpperFirst() /]In[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /]([entityType.name.toLowerFirst()/])|| inserted ;
	[/for]
	[/for]
	// Insert in structures containing double embedded role
	[for (struct: AbstractPhysicalStructure | getMappedComplexEmbeddedStructureOfEntity(entityType, entityType.ancestors(Domainmodel)->first()))]
	[for (db: Database | getConcernedDatabases(struct, entityType.ancestors(Domainmodel)->first()))]
    inserted = insert[entityType.name.toUpperFirst() /]In[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /]([entityType.name.toLowerFirst() /][for (role: Role | getMandatoryRoles(entityType, conceptualSchema))],[role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/][/for][for (attr: Attribute | getAttributesFromMandatoryRoles(entityType, conceptualSchema))], [getRelationshipType(attr).name /]_[attr.name /][/for]) || inserted ;
	[/for]
	[/for]
	// Insert in descending structures
	[for (struct: AbstractPhysicalStructure | getDescendingOneLevelPhysicalStructuresOfEntity(entityType, entityType.ancestors(Domainmodel)->first()))]
	[for (db: Database | getConcernedDatabases(struct, entityType.ancestors(Domainmodel)->first()))]
	inserted = insert[entityType.name.toUpperFirst() /]In[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /]([entityType.name.toLowerFirst() /][for (role: Role | getMandatoryRoles(entityType, conceptualSchema))],[role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/][/for][for (attr: Attribute | getAttributesFromMandatoryRoles(entityType, conceptualSchema))], [getRelationshipType(attr).name /]_[attr.name /][/for])|| inserted ;
	[/for]
	[/for]
	// Insert in ascending structures 
	[for (struct: AbstractPhysicalStructure | getAscendingPhysicalStructuresOfEntity(entityType, entityType.ancestors(Domainmodel)->first()))]
	[for (db: Database | getConcernedDatabases(struct, entityType.ancestors(Domainmodel)->first()))]
	inserted = insert[entityType.name.toUpperFirst() /]In[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /]([entityType.name.toLowerFirst() /][for (role: Role | getMandatoryRoles(entityType, conceptualSchema))],[role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/][/for][for (attr: Attribute | getAttributesFromMandatoryRoles(entityType, conceptualSchema))], [getRelationshipType(attr).name /]_[attr.name /][/for])|| inserted ;
	[/for]
	[/for]
	// Insert in ref structures 
	[for (struct: AbstractPhysicalStructure | getRemainingRefStructureOfMappedMandatoryRoleOfEntity(entityType, entityType.ancestors(Domainmodel)->first()))]
	[for (db: Database | getConcernedDatabases(struct, entityType.ancestors(Domainmodel)->first()))]
	inserted = insert[entityType.name.toUpperFirst() /]In[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /]([entityType.name.toLowerFirst() /][for (role: Role | getMandatoryRoles(entityType, conceptualSchema))],[role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/][/for][for (attr: Attribute | getAttributesFromMandatoryRoles(entityType, conceptualSchema))], [getRelationshipType(attr).name /]_[attr.name /][/for])|| inserted ;
	[/for]
	[/for]
	// Insert in ref structures mapped to opposite role of mandatory role  
	[for (struct: AbstractPhysicalStructure | getRemainingRefStructureMappedToOppositeOfMandatoryRoleOfEntity(entityType, entityType.ancestors(Domainmodel)->first()))]
	[for (db: Database | getConcernedDatabases(struct, entityType.ancestors(Domainmodel)->first()))]
	inserted = insert[entityType.name.toUpperFirst() /]In[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /]([entityType.name.toLowerFirst() /][for (role: Role | getMandatoryRoles(entityType, conceptualSchema))],[role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/][/for][for (attr: Attribute | getAttributesFromMandatoryRoles(entityType, conceptualSchema))], [getRelationshipType(attr).name /]_[attr.name /][/for])|| inserted ;
	[/for]
	[/for]
	return inserted;
}[/template]

[template public insertPOJOImpl(entityType: EntityType, conceptualSchema: ConceptualSchema)]{
	// Insert into all mapped standalone AbstractPhysicalStructure 
	boolean inserted = false;
	[for (struct: AbstractPhysicalStructure | getMappedPhysicalStructureToInsertSingleE(entityType, entityType.ancestors(Domainmodel)->first()))]
	[for (db: Database | getConcernedDatabases(struct, entityType.ancestors(Domainmodel)->first()))]
		inserted = insert[entityType.name.toUpperFirst() /]In[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /]([entityType.name.toLowerFirst()/]) || inserted ;
	[/for]
	[/for]
	return inserted;
}[/template]

[template public generateCheckExistBeforeInsert(entityType: EntityType, struct : AbstractPhysicalStructure, db : Database)]
	Condition<[entityType.name.toUpperFirst()/]Attribute> conditionID;
	boolean entityExists=false;
	[if (entityType.identifier.oclIsUndefined()=false)]
	[for (attr : Attribute | entityType.identifier.attributes)]
		[if (i=1)]
	conditionID = Condition.simple([entityType.name.toUpperFirst()/]Attribute.[attr.name/], Operator.EQUALS, [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
		[else]
	conditionID = Condition.and(conditionID, Condition.simple([entityType.name.toUpperFirst()/]Attribute.[attr.name/], Operator.EQUALS, [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]()));
		[/if]
	[/for]
	Dataset res = get[entityType.name.toUpperFirst() /]ListIn[struct.name.toUpperFirst()/]From[db.name.toUpperFirst() /](conditionID,new MutableBoolean(false));
	entityExists = res != null && !res.isEmpty();
	[/if]
			
[/template]

[template public insertInComplexEmbeddedStructure(entityType: EntityType, struct : AbstractPhysicalStructure, db : Database)]
	[generateDocument(entityType, struct.oclAsType(pml::Collection).fields, struct.oclAsType(pml::Collection).name,1,0,true)/]
	DBConnectionMgr.insertMany(List.of(doc[struct.name/]_1), "[struct.name/]", "[db.name/]");
	return true;
	
[/template]

[template public insertInDescendingStructure(entityType: EntityType, struct : AbstractPhysicalStructure, db : Database)]
[comment generate structType for Ent and for subsequent roles. Join them together in descending way. /]
	 // Implement Insert in descending complex struct
[comment]Insert using Spark[/comment]
[comment]	[generateStructField(entityType,struct.oclAsType(pml::Collection).fields, struct.oclAsType(pml::Collection).name,1,false)/]
	List<Row> listRows=new ArrayList<Row>();
	StructType struct = DataTypes.createStructType(listOfStructField[struct.oclAsType(pml::Collection).name/]_1);
	listRows.add(RowFactory.create(values[struct.oclAsType(pml::Collection).name/]_1.toArray()));
	SparkConnectionMgr.writeDataset(listRows, struct, "mongo", "[struct.name/]", "[db.name/]");[/comment]
[insertInMongoDBImpl(entityType, struct, db) /]
	return true;
[/template]

[template public insertInAscendingStructure(entityType: EntityType, struct : AbstractPhysicalStructure, db : Database)]
	 // Implement Insert in ascending complex struct

	Bson filter= new Document();
	Bson updateOp;
	String addToSet;
	List<String> fieldName= new ArrayList();
	List<Bson> arrayFilterCond = new ArrayList();
	[let field : PhysicalField = getMappedPhysicalFieldOfRoleOfEntityWhereOppositeRoleIsMandatory(struct, entityType, entityType.getMappingRules())]
	[let role : Role = getMappedRoleOfPhysicalField(field)]
	[generateDocument(entityType,field.oclAsType(EmbeddedObject).fields, getPhysicalName(field),1,0,true)/]
	[if (field.eContainer(EmbeddedObject).oclIsUndefined()=false)]
	[ascendInStruct(field.eContainer(EmbeddedObject), getMappedRoleOfPhysicalField(field),struct, db, 0, entityType)/]
	fieldName.add("[getPhysicalName(field)/]");
	addToSet = String.join(".",fieldName);
	updateOp = addToSet(addToSet,doc[getPhysicalName(field)/]_1);
	DBConnectionMgr.upsertMany(filter, updateOp, arrayFilterCond, "[struct.name/]", "[db.name/]");
	[else] 
	// level 1 ascending
	[comment for each mandatory role object in list, in ascending structure we need to update the document. /]
				[if (role.getOppositeRoleInBinaryRel().isCardinalityMaxN())]
	for([role.entity.name.toUpperFirst()/] [role.entity.name.toLowerFirst()/] : [role.name/][getRelationShipType(role).name.toUpperFirst()/]){
				[else]
	[role.entity.name.toUpperFirst()/] [role.entity.name.toLowerFirst()/] = [role.name/][getRelationShipType(role).name.toUpperFirst()/];
				[/if]
			[for (attr : Attribute | role.entity.identifier.attributes)]
				[if (i=1)]
		filter = eq("[getPhysicalName(getMappedPhysicalField(attr, struct, db, entityType.getMappingRules()))/]",[role.entity.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
				[else]
		filter = and(filter,eq("[getPhysicalName(getMappedPhysicalField(attr, struct, db, entityType.getMappingRules()))/]",[role.entity.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
				[/if]
			[/for]
		updateOp = addToSet("[field.getPhysicalName()/]", doc[getPhysicalName(field)/]_1);
		DBConnectionMgr.upsertMany(filter, updateOp, "[struct.name/]", "[db.name/]");					
	[if (role.getOppositeRoleInBinaryRel().isCardinalityMaxN())]
	}
	[/if] 

	[/if]	
	[/let]
	[/let]
	return true;
[/template]

[template public ascendInStruct(embeddedObj : EmbeddedObject, role : Role, struct: AbstractPhysicalStructure, db:Database, level : Integer, roleEntityType : EntityType) ]
fieldName.add("[embeddedObj.getPhysicalName()/].$['['/][embeddedObj.getPhysicalName()/][']'/]");
[if (level>0)]
	[if (role.getOppositeRoleInBinaryRel().isCardinalityMaxN())]
	List<[role.entity.name.toUpperFirst()/]> [role.name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/] = [roleEntityType.name.toLowerFirst()/]._get[role.getOppositeRoleInBinaryRel().name.toUpperFirst()/]List();
	[else]
		[role.entity.name.toUpperFirst()/] [role.name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/] = [roleEntityType.name.toLowerFirst()/]._get[role.getOppositeRoleInBinaryRel().name/]();
	[/if]
	if([role.name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/]==null [if (role.getOppositeRoleInBinaryRel().isCardinalityMaxN())]|| [role.name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/].size()==0[/if]){
		logger.error("Physical Structure contains embedded attributes or reference to an indirectly linked object. Please set role attribute '[role.name/]' of type '[role.getOppositeRoleInBinaryRel().entity.name.toUpperFirst()/]' in entity object '[roleEntityType.name.toUpperFirst()/]");
		throw new PhysicalStructureException("Physical Structure contains embedded attributes or reference to an indirectly linked object. Please set role attribute '[role.name/]' of type '[role.getOppositeRoleInBinaryRel().entity.name.toUpperFirst()/]' in entity object '[roleEntityType.name.toUpperFirst()/]");
	}
[/if]
[if (role.getOppositeRoleInBinaryRel().isCardinalityMaxN())]
List<String> idvalues = new ArrayList<>();
for([role.entity.name.toUpperFirst()/] [role.entity.name.toLowerFirst()/] : [role.name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/]){
	[for (attr : Attribute | role.entity.identifier.attributes)]
				[if (i=1)]
	idvalues.add([role.entity.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
				[else]
// TODO Handle multi attributes identifier
throw new UnsupportedOperationException("Multi component identifier not supported");
				[/if]
arrayFilterCond.add(in("[embeddedObj.getPhysicalName()/].[getPhysicalName(getMappedPhysicalField(attr, struct, db, attr.getMappingRules()))/]",idvalues));
	[/for]
}
[else]
[role.entity.name.toUpperFirst()/] [role.entity.name.toLowerFirst()/] = [role.name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/];
	[for (attr : Attribute | role.entity.identifier.attributes)]
				[if (i=1)]
arrayFilterCond.add(eq("[embeddedObj.getPhysicalName()/].[getPhysicalName(getMappedPhysicalField(attr, struct, db, attr.getMappingRules()))/]",[role.entity.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]()));
				[else]
// TODO Handle multi attributes identifier
throw new UnsupportedOperationException("Multi component identifier not supported");
				[/if]
	[/for]
[/if]
[if (embeddedObj.eContainer(EmbeddedObject).oclIsUndefined()=false)]
[ascendInStruct(embeddedObj.eContainer(EmbeddedObject),getMappedRoleOfPhysicalField(embeddedObj), struct, db,level+1, role.entity)/]
[/if]
[/template]
	
[template public insertInRefStructure(entityType: EntityType, struct : AbstractPhysicalStructure, db : Database)]
	 // Implement Insert in structures with mandatory references
[if (struct.oclIsTypeOf(Table))]
	List<String> columns = new ArrayList<>();
	List<Object> values = new ArrayList<>();
	List<List<Object>> rows = new ArrayList<>();
	Object [entityType.name.toLowerFirst()/]Id;
[comment]Normal fields [/comment]
	[for (field : PhysicalField | struct.oclAsType(Table).columns)]
		[if (field.oclIsTypeOf(ShortField))]
			[let attr : Attribute = getMappedAttributes(field, entityType, entityType.getMappingRules())->any(true)]
				[if (attr.oclIsUndefined()=false)]
columns.add("[getPhysicalName(field)/]");
values.add([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
				[/if]
			[/let] 
		[/if]
		[if (field.oclIsTypeOf(LongField))]
		[comment LongField with only one component and is BracketsField /]
			[if (field.oclAsType(LongField).pattern->size()=1 and field.oclAsType(LongField).pattern->any(true).oclIsTypeOf(BracketsField))]
				[let brackets : BracketsField = field.oclAsType(LongField).pattern->any(true).oclAsType(BracketsField)]
					[let attr : Attribute = getMappedAttributes(field, entityType, entityType.getMappingRules())->any(true)]
					[if (attr.oclIsUndefined()=false)]
columns.add("[getPhysicalName(field)/]");
values.add([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
					[/if]
					[/let] 
				[/let]
			[else]
				[if (field.oclAsType(LongField).pattern->filter(BracketsField)->exists(b |getMappedAttributes(b, entityType, entityType.getMappingRules())->size()=0)=false)]
				[comment All BracketsField are mapped to the corresponding entity or composed of only one Terminal expression/]
				[comment LongField is composed of component, therefore can only be StringType /]
String value_[getPhysicalName(field)/] = "";
					[for (component : TerminalExpression | field.oclAsType(LongField).pattern)]
						[if (component.oclIsTypeOf(BracketsField))]
							[let attr : Attribute = getMappedAttributes(component.oclAsType(BracketsField), entityType, entityType.getMappingRules())->any(true)]
value_[getPhysicalName(field)/] += [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
							[/let]
						[else]
value_[getPhysicalName(field)/] += "[component.literal/]";
						[/if]
					[/for]
columns.add("[getPhysicalName(field)/]");
values.add(value_[getPhysicalName(field)/]);
				[/if]
			[/if]
		[/if]
	[/for]
[comment]	Reference fields [/comment]
	[if (isJoinStructureOfMappedMandatoryRoleOfEntity(entityType, struct, entityType.ancestors(Domainmodel)->first()))]
[comment]Join structure  A <- AB -> B[/comment]
		[for (ref : Reference | getRefOfPhysicalStructure(struct))]
			[let role : Role = getMappedRoleOfReference(ref)]
			[if (role.entity.name = entityType.name)]
	// Role in join structure 
	columns.add("[ref.sourceField->any(true).oclAsType(PhysicalField).getPhysicalName()/]");
	[entityType.name.toLowerFirst()/]Id = [entityType.name.toLowerFirst()/].get[getMappedAttributeOfFieldInStructure(ref.targetField->any(true).oclAsType(PhysicalField), ref.targetField->any(true).oclAsType(PhysicalField).getAbstractPhysicalStructureNotEmbeddedObject()).name.toUpperFirst()/]();
			[/if]
			[/let]
		[/for]
		[for (ref : Reference | getRefOfPhysicalStructure(struct))]
			[let role : Role = getMappedRoleOfReference(ref)]
			[if (not (role.entity.name = entityType.name))]
	columns.add("[ref.sourceField->any(true).oclAsType(PhysicalField).getPhysicalName()/]");
				[if (role.getOppositeRoleInBinaryRel().isCardinalityMaxN())]
	for([role.entity.name.toUpperFirst()/] [role.entity.name.toLowerFirst()/] : [role.name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/]){
				[else]
		[role.entity.name.toUpperFirst()/] [role.entity.name.toLowerFirst()/] = [role.name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/];
				[/if]
		values = new ArrayList<>();
		values.add([entityType.name.toLowerFirst()/]Id);
		values.add([role.entity.name.toLowerFirst()/].get[getMappedAttributeOfFieldInStructure(ref.targetField->any(true).oclAsType(PhysicalField), ref.targetField->any(true).oclAsType(PhysicalField).getAbstractPhysicalStructureNotEmbeddedObject()).name.toUpperFirst()/]());
		rows.add(values);
				[if (role.getOppositeRoleInBinaryRel().isCardinalityMaxN())]
	}	
				[/if]
			[/if]
			[/let] 
		[/for]
	[else]
[comment]// A -> B[/comment]
		[for (ref : Reference | getRefOfPhysicalStructure(struct))]
			[let role : Role = getMappedRoleOfReference(ref)]
			[if (role.isMandatoryRole())]
	// Ref '[ref.name/]' mapped to role '[role.name/]'
	columns.add("[ref.sourceField->any(true).oclAsType(PhysicalField).getPhysicalName()/]");
	values.add([role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][role.getRelationShipType().name.toUpperFirst()/].get[getMappedAttributeOfFieldInStructure(ref.targetField->any(true).oclAsType(PhysicalField), ref.targetField->any(true).oclAsType(PhysicalField).getAbstractPhysicalStructureNotEmbeddedObject()).name.toUpperFirst()/]());
			[/if]
			[/let]
		[/for]
	rows.add(values);
	[/if]
	DBConnectionMgr.insertInTable(columns, rows, "[struct.name/]", "[db.name/]");
	return true;
[else]
[if (struct.oclIsTypeOf(pml::Collection))]
[comment]//Docdb ref support.  [/comment]
// In insertRefStruct in MongoDB
Bson filter = new Document();
Bson updateOp;
List<Document> docsList = new ArrayList();
Document doc = new Document();
String roleEntityField;
java.util.Map<String, java.util.Map<String, String>> longFieldValues = new java.util.HashMap<String, java.util.Map<String, String>>();

	[comment]Normal fields [/comment]
	[for (attr : Attribute | entityType.attributes)]
		[let field : PhysicalField = getMappedPhysicalField(attr, struct, db, db.getMappingRules())]
		[if (field <> null)]
			[if (field.ancestors(LongField) -> size() = 0)]
			[comment]Short fields [/comment]
doc.append("[getPhysicalName(field)/]", [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
			[else]
			[comment]Long fields [/comment]
java.util.Map<String, String> longFieldValue = longFieldValues.get("[getPhysicalName(field.ancestors(LongField) -> first().oclAsType(LongField))/]");
if(longFieldValue == null) {
	longFieldValue = new java.util.HashMap<String, String>();
	longFieldValues.put("[getPhysicalName(field.ancestors(LongField) -> first().oclAsType(LongField))/]", longFieldValue);
}
longFieldValue.put("[field.oclAsType(BracketsField).name/]", (value == null ? null : value.toString()));
			[/if]
		[/if]
		[/let]
	[/for]
for(java.util.Map.Entry<String, java.util.Map<String, String>> entry : longFieldValues.entrySet()) {
	String longField = entry.getKey();
	java.util.Map<String, String> values = entry.getValue();
	[for (lf : LongField | struct.getDescendentsLongField())]
	if(longField.equals("[getPhysicalName(lf)/]")) {
		String value;
		String v;
		[for (expr : TerminalExpression | lf.pattern)]
			[if (expr.oclIsTypeOf(pml::BracketsField))]
		v = values.get("[expr.oclAsType(BracketsField).name/]");
			[else]
		v = "[expr.literal/]";
			[/if]
			[if (i = 1)]
		value = v;
			[else]
		value += v;
			[/if]
		[/for]

		String fieldName = "[getPhysicalName(lf)/]";
		doc.append(fieldName, value);
	}
			[/for]
}	

[comment]	Reference fields [/comment]
	[if (isJoinStructureOfMappedMandatoryRoleOfEntity(entityType, struct, entityType.ancestors(Domainmodel)->first()))]
	[comment]Join structure  A <- AB -> B[/comment]
		[for (ref : Reference | getRefOfPhysicalStructure(struct))]
			[let role : Role = getMappedRoleOfReference(ref)]
			[if (role.entity.name = entityType.name)]
	// Role in join structure 
	roleEntityField = "[ref.sourceField->any(true).oclAsType(PhysicalField).getPhysicalName()/]";
			[/if]
			[/let]
		[/for]
		[for (ref : Reference | getRefOfPhysicalStructure(struct))]
			[let role : Role = getMappedRoleOfReference(ref)]
			[if (not (role.entity.name = entityType.name))]
				[if (role.getOppositeRoleInBinaryRel().isCardinalityMaxN())]
	for([role.entity.name.toUpperFirst()/] [role.entity.name.toLowerFirst()/] : [role.name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/]){
				[else]
		[role.entity.name.toUpperFirst()/] [role.entity.name.toLowerFirst()/] = [role.name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/];
				[/if]
		doc = new Document();
		doc.append(roleEntityField,[entityType.name.toLowerFirst()/].get[getMappedAttributeOfFieldInStructure(ref.targetField->any(true).oclAsType(PhysicalField), ref.targetField->any(true).oclAsType(PhysicalField).getAbstractPhysicalStructureNotEmbeddedObject()).name.toUpperFirst()/]());
		doc.append("[ref.sourceField->any(true).oclAsType(PhysicalField).getPhysicalName()/]",[role.entity.name.toLowerFirst()/].get[getMappedAttributeOfFieldInStructure(ref.targetField->any(true).oclAsType(PhysicalField), ref.targetField->any(true).oclAsType(PhysicalField).getAbstractPhysicalStructureNotEmbeddedObject()).name.toUpperFirst()/]());
		docsList.add(doc);
				[if (role.getOppositeRoleInBinaryRel().isCardinalityMaxN())]
	}	
				[/if]
			[/if]
			[/let] 
		[/for]
	[else]
[comment]// A -> B[/comment]
		[for (ref : Reference | getRefOfPhysicalStructure(struct))]
			[let role : Role = getMappedRoleOfReference(ref)]
			[if (role.isMandatoryRole())]
// Ref '[ref.name/]' mapped to role '[role.name/]'
doc.append("[ref.sourceField->any(true).oclAsType(PhysicalField).getPhysicalName()/]",[role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][role.getRelationShipType().name.toUpperFirst()/].get[getMappedAttributeOfFieldInStructure(ref.targetField->any(true).oclAsType(PhysicalField), ref.targetField->any(true).oclAsType(PhysicalField).getAbstractPhysicalStructureNotEmbeddedObject()).name.toUpperFirst()/]());
docsList.add(doc);
			[/if]
			[/let]
		[/for]
	[/if]
	DBConnectionMgr.insertMany(docsList, "[struct.name/]", "[db.name/]");
	return true;
[else]
[if (struct.oclIsTypeOf(pml::KeyValuePair))]
	// In insertRefStruct in KeyValuePair
	// In Key value database
				[for (ref : Reference | getRefOfPhysicalStructure(struct))]
				[let roleref : Role = getMappedRoleOfReference(ref)]
				[if (roleref.isMandatoryRole())]
				[let oppositerole : Role = roleref.getOppositeRoleInBinaryRel()]
					[if (entityType=roleref.entity)]
						[if (roleref.isCardinalityMaxN())]
	for([oppositerole.entity.name.toUpperFirst()/] [oppositerole.entity.name.toLowerFirst()/] : [oppositerole.name/][getRelationShipType(oppositerole).name.toUpperFirst()/]){
						[else]
	[oppositerole.entity.name.toUpperFirst()/] [oppositerole.entity.name.toLowerFirst()/] = [oppositerole.name/][getRelationShipType(oppositerole).name.toUpperFirst()/];
						[/if]
	// Build key
		String key[roleref.name.toUpperFirst()/]="";
		String value[roleref.name.toUpperFirst()/]="";
						[for (component : TerminalExpression | struct.oclAsType(KeyValuePair).key.pattern)]
							[if (component.oclIsTypeOf(BracketsField))]
							[let attr : Attribute = getMappedAttributeOfFieldInStructure(component.oclAsType(PhysicalField),struct)]
								[if (attr.ancestors(EntityType)->first()=entityType)]
		key[roleref.name.toUpperFirst()/] += [roleref.entity.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
								[else]
		key[roleref.name.toUpperFirst()/] += [getOppositeRoleInBinaryRel(roleref).entity.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
								[/if]
							[/let]
							[else]
		key[roleref.name.toUpperFirst()/] += "[component.literal/]";
							[/if]
						[/for]
		// Value part
						[if (struct.oclAsType(KeyValuePair).value.oclIsTypeOf(pml::KVComplexField) and struct.oclAsType(KeyValuePair).value.oclAsType(pml::KVComplexField).type=pml::KVDataType::HASH)]
		// Generate for hash value
		[generateValueForHashStructure(struct,entityType,roleref.name.toUpperFirst())/]
		SparkConnectionMgr.writeKeyValueHash(key[roleref.name.toUpperFirst()/],hash[roleref.name.toUpperFirst()/], "[db.name/]");
						[else]
		[comment Generate value for simple string value /]
		// Generate Value for List 
							[if (ref.sourceField.ancestors(KVComplexField)->first().type=pml::KVDataType::LIST)]
							[let attr : Attribute = getMappedAttributeOfFieldInStructure(ref.targetField->any(true).oclAsType(PhysicalField),ref.targetField->any(true).oclAsType(PhysicalField).getAbstractPhysicalStructureNotEmbeddedObject())]
		value[roleref.name.toUpperFirst()/] =  Util.getStringValue([oppositerole.entity.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
							[/let]
		DBConnectionMgr.writeKeyValueList(key[roleref.name.toUpperFirst()/],value[roleref.name.toUpperFirst()/],"[db.name/]");
							[/if]
						[/if]
					[if (roleref.isCardinalityMaxN())]
	}
					[/if]
					[/if]
				[/let]
				[/if]
				[/let]
				[/for]
	return false;
[/if]
[/if]
[/if]
[/template]

[template public insertInRefStructureOfOppositeRole(entityType: EntityType, struct : AbstractPhysicalStructure, db : Database)]
 	// Entity '[entityType.name/]' reference in structure '[struct.name/]'
	[if (struct.oclIsTypeOf(Table))]
	// In relational table
	List<String> columns = new ArrayList<>();
	List<Object> values = new ArrayList<>();
	String filtercolumn; 
	Object filtervalue;
		[for (ref : Reference | getRefOfPhysicalStructure(struct))]
		[let roleref : Role = getMappedRoleOfReference(ref)]
			[if (entityType=getOppositeRoleInBinaryRel(roleref).entity)]
	columns.add("[ref.sourceField->any(true).oclAsType(PhysicalField).getPhysicalName()/]");
	values.add([getOppositeRoleInBinaryRel(roleref).entity.name.toLowerFirst()/].get[getMappedAttributeOfFieldInStructure(ref.targetField->any(true).oclAsType(PhysicalField), ref.targetField->any(true).oclAsType(PhysicalField).getAbstractPhysicalStructureNotEmbeddedObject()).name.toUpperFirst()/]());
			[for (attr : Attribute | roleref.entity.identifier.attributes)]
						[if (i=1)]
	filtercolumn = "[getPhysicalName(getMappedPhysicalField(attr, struct, db, roleref.entity.getMappingRules()))/]";
	filtervalue = [roleref.name.toLowerFirst()/][getRelationShipType(roleref).name.toUpperFirst()/].get[attr.name.toUpperFirst()/]();
						[else]
	logger.error("To implement. Support of multi valued identifiers");
	throw new UnsupportedOperationException("Can't handle multi valued identifiers");
						[/if]
			[/for]
			[/if]
		[/let]
		[/for]
	DBConnectionMgr.updateInTable(filtercolumn, filtervalue, columns, values, "[struct.name/]", "[db.name/]");					
	return true;
	[else]
		[if (struct.oclIsTypeOf(pml::Collection))]
	// In document db
	Bson filter;
	Bson updateOp;
			[for (ref : Reference | getRefOfPhysicalStructure(struct))]
				[let roleref : Role = getMappedRoleOfReference(ref)]
				[if (entityType=getOppositeRoleInBinaryRel(roleref).entity)]
					[if (ref.sourceField->any(true).oclIsTypeOf(ArrayField))]
	updateOp = addToSet("[ref.sourceField->any(true).oclAsType(PhysicalField).getPhysicalName()/]",[getOppositeRoleInBinaryRel(roleref).entity.name.toLowerFirst()/].get[getMappedAttributeOfFieldInStructure(ref.targetField->any(true).oclAsType(PhysicalField), ref.targetField->any(true).oclAsType(PhysicalField).getAbstractPhysicalStructureNotEmbeddedObject()).name.toUpperFirst()/]());
					[else]
	updateOp = set("[ref.sourceField->any(true).oclAsType(PhysicalField).getPhysicalName()/]",[getOppositeRoleInBinaryRel(roleref).entity.name.toLowerFirst()/].get[getMappedAttributeOfFieldInStructure(ref.targetField->any(true).oclAsType(PhysicalField), ref.targetField->any(true).oclAsType(PhysicalField).getAbstractPhysicalStructureNotEmbeddedObject()).name.toUpperFirst()/]());
					[/if]
					[for (attr : Attribute | roleref.entity.identifier.attributes)]
						[if (i=1)]
	filter = eq("[getPhysicalName(getMappedPhysicalField(attr, struct, db, entityType.getMappingRules()))/]",[roleref.name.toLowerFirst()/][roleref.getRelationShipType().name.toUpperFirst()/].get[attr.name.toUpperFirst()/]());
						[else]
	filter = and(filter,eq("[getPhysicalName(getMappedPhysicalField(attr, struct, db, entityType.getMappingRules()))/]",[roleref.name.toLowerFirst()/][roleref.getRelationShipType().name.toUpperFirst()/].get[attr.name.toUpperFirst()/]());
						[/if]
					[/for]
	DBConnectionMgr.update(filter, updateOp, "[struct.name/]", "[db.name/]");
	return true;
				[/if]
				[/let]
			[/for]
		[else]
			[if (struct.oclIsTypeOf(pml::KeyValuePair))]
	// In Key value database
				[for (ref : Reference | getRefOfPhysicalStructure(struct))]
				[let roleref : Role = getMappedRoleOfReference(ref)]
					[if (entityType=getOppositeRoleInBinaryRel(roleref).entity)]
						[if (roleref.getOppositeRoleInBinaryRel().isCardinalityMaxN())]
	for([roleref.entity.name.toUpperFirst()/] [roleref.entity.name.toLowerFirst()/] : [roleref.name/][getRelationShipType(roleref).name.toUpperFirst()/]){
						[else]
	[roleref.entity.name.toUpperFirst()/] [roleref.entity.name.toLowerFirst()/] = [roleref.name/][getRelationShipType(roleref).name.toUpperFirst()/];
						[/if]
	// Build key
		String key="";
		String value="";
						[for (component : TerminalExpression | struct.oclAsType(KeyValuePair).key.pattern)]
							[if (component.oclIsTypeOf(BracketsField))]
							[let attr : Attribute = getMappedAttributeOfFieldInStructure(component.oclAsType(PhysicalField),struct)]
								[if (attr.ancestors(EntityType)->first()=entityType)]
		key += [getOppositeRoleInBinaryRel(roleref).entity.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
								[else]
		key += [roleref.entity.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
								[/if]
							[/let]
							[else]
		key += "[component.literal/]";
							[/if]
						[/for]
						[if (ref.sourceField.ancestors(KVComplexField)->first().type=pml::KVDataType::LIST)]
		// Value part in List
						[let attr : Attribute = getMappedAttributeOfFieldInStructure(ref.targetField->any(true).oclAsType(PhysicalField),ref.targetField->any(true).oclAsType(PhysicalField).getAbstractPhysicalStructureNotEmbeddedObject())]
		value =  Util.getStringValue([getOppositeRoleInBinaryRel(roleref).entity.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
						[/let]
		DBConnectionMgr.writeKeyValueList(key,value,"[db.name/]");
						[/if]
					[if (roleref.getOppositeRoleInBinaryRel().isCardinalityMaxN())]
	}
					[/if]
					[/if]
				[/let]
				[/for]
	return false;
				
			[/if]
		[/if]
	[/if]
	
[/template]

[template public insertInSQLDBImpl(entityType : EntityType, struct : AbstractPhysicalStructure, db : Database)]
[comment]	List<Row> listRows=new ArrayList<Row>();
	[generateStructField(entityType,struct.oclAsType(Table).columns, struct.oclAsType(Table).name,1,false)/]
	StructType structType = DataTypes.createStructType(listOfStructField[struct.oclAsType(Table).name/]_1);
	listRows.add(RowFactory.create(values[struct.oclAsType(Table).name/]_1.toArray()));
	SparkConnectionMgr.writeDataset(listRows, structType, "jdbc", "[struct.name/]", "[db.name/]");[/comment]
	List<String> columns = new ArrayList<>();
	List<Object> values = new ArrayList<>();	
[for (field : PhysicalField | struct.oclAsType(Table).columns)]
	[if (field.oclIsTypeOf(ShortField))]
		[let attr : Attribute = getMappedAttributes(field, entityType, entityType.getMappingRules())->any(true)]
			[if (attr.oclIsUndefined()=false)]
	columns.add("[getPhysicalName(field)/]");
	values.add([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
			[/if]
		[/let] 
	[/if]
	[if (field.oclIsTypeOf(LongField))]
		[comment LongField with only one component and is BracketsField /]
		[if (field.oclAsType(LongField).pattern->size()=1 and field.oclAsType(LongField).pattern->any(true).oclIsTypeOf(BracketsField))]
			[let brackets : BracketsField = field.oclAsType(LongField).pattern->any(true).oclAsType(BracketsField)]
				[let attr : Attribute = getMappedAttributes(field, entityType, entityType.getMappingRules())->any(true)]
				[if (attr.oclIsUndefined()=false)]
	columns.add("[getPhysicalName(field)/]");
	values.add([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
				[/if]
				[/let] 
			[/let]
		[else]
			[if (field.oclAsType(LongField).pattern->filter(BracketsField)->exists(b |getMappedAttributes(b, entityType, entityType.getMappingRules())->size()=0)=false)]
				[comment All BracketsField are mapped to the corresponding entity or composed of only one Terminal expression/]
				[comment LongField is composed of component, therefore can only be StringType /]
	String value_[getPhysicalName(field)/] = "";
				[for (component : TerminalExpression | field.oclAsType(LongField).pattern)]
					[if (component.oclIsTypeOf(BracketsField))]
						[let attr : Attribute = getMappedAttributes(component.oclAsType(BracketsField), entityType, entityType.getMappingRules())->any(true)]
	value_[getPhysicalName(field)/] += [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
						[/let]
					[else]
	value_[getPhysicalName(field)/] += "[component.literal/]";
					[/if]
				[/for]
	columns.add("[getPhysicalName(field)/]");
	values.add(value_[getPhysicalName(field)/]);
			[/if]
		[/if]
	[/if]
[/for]
	DBConnectionMgr.insertInTable(columns, Arrays.asList(values), "[struct.name/]", "[db.name/]");
[/template]

[template public insertInMongoDBImpl(entityType : EntityType, struct : AbstractPhysicalStructure, db : Database)]
[comment]	List<Row> listRows=new ArrayList<Row>();
	[generateStructField(entityType, struct.oclAsType(pml::Collection).fields,struct.oclAsType(pml::Collection).name,1,false)/]
	StructType struct = DataTypes.createStructType(listOfStructField[struct.oclAsType(pml::Collection).name/]_1);
	listRows.add(RowFactory.create(values[struct.oclAsType(pml::Collection).name/]_1.toArray()));
	SparkConnectionMgr.writeDataset(listRows, struct, "mongo", "[struct.name/]", "[db.name/]");[/comment]
	Bson filter = new Document();
	Bson updateOp;
	[generateDocument(entityType, struct.oclAsType(pml::Collection).fields, struct.oclAsType(pml::Collection).name,1,0,true)/]
	[for (attr : Attribute | entityType.identifier.attributes)]
				[if (i=1)]
	filter = eq("[getPhysicalName(getMappedPhysicalField(attr, struct, db, entityType.getMappingRules()))/]",[entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
				[else]
	filter = and(filter,eq("[getPhysicalName(getMappedPhysicalField(attr, struct, db, entityType.getMappingRules()))/]",[entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
				[/if]
	[/for]
	updateOp = setOnInsert(doc[struct.name/]_1);
	DBConnectionMgr.upsertMany(filter, updateOp, "[struct.name/]", "[db.name/]");
[/template]


[template public insertInRedisImpl(entityType : EntityType, struct : AbstractPhysicalStructure, db : Database)]
[comment insertEInREDIS(ENT e)
 /]
		String key="";
		[for (component : TerminalExpression | struct.oclAsType(KeyValuePair).key.pattern)]
						[if (component.oclIsTypeOf(BracketsField))]
							[let attr : Attribute = getMappedAttributes(component.oclAsType(BracketsField), entityType, entityType.getMappingRules())->any(true)]
		key += [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
							[/let]
						[else]
		key += "[component.literal/]";
						[/if]
		[/for]
		[if (struct.oclAsType(KeyValuePair).value.oclIsTypeOf(pml::KVComplexField) and struct.oclAsType(KeyValuePair).value.oclAsType(pml::KVComplexField).type=pml::KVDataType::HASH)]
		// Generate for hash value
		[generateValueForHashStructure(struct,entityType,'')/]
		SparkConnectionMgr.writeKeyValueHash(key,hash, "[db.name/]");
		[else]
		[comment Generate value for simple string value /]
		boolean toAdd = false;
		String value="";
			[let field : PhysicalField = struct.oclAsType(KeyValuePair).value]
			[if (struct.oclAsType(KeyValuePair).value.oclIsTypeOf(ShortField))]
					[let attr : Attribute = getMappedAttributes(field, entityType, entityType.getMappingRules())->any(true)]
						[if (attr.oclIsUndefined()=false)]
		if([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]()!=null){
			toAdd = true;
			value += [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
		}
						[/if]
					[/let] 
			[/if]
			[if (field.oclIsTypeOf(LongField))]
			[comment LongField with only one component and is BracketsField /]
				[if (field.oclAsType(LongField).pattern->size()=1 and field.oclAsType(LongField).pattern->any(true).oclIsTypeOf(BracketsField))]
					[let brackets : BracketsField = field.oclAsType(LongField).pattern->any(true).oclAsType(BracketsField)]
						[let attr : Attribute = getMappedAttributes(field, entityType, entityType.getMappingRules())->any(true)]
						[if (attr.oclIsUndefined()=false)]
		if([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]()!=null){
			toAdd = true;
			value += [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
		}
						[/if]
						[/let] 
					[/let]
				[else]
					[if (field.oclAsType(LongField).pattern->filter(BracketsField)->exists(b |getMappedAttributes(b, entityType, entityType.getMappingRules())->size()=0)=false)]
						[comment All BracketsField are mapped to the corresponding entity or composed of only one Terminal expression/]
						[comment LongField is composed of component, therefore can only be StringType /]
						[for (component : TerminalExpression | field.oclAsType(LongField).pattern)]
							[if (component.oclIsTypeOf(BracketsField))]
								[let attr : Attribute = getMappedAttributes(component.oclAsType(BracketsField), entityType, entityType.getMappingRules())->any(true)]
		if([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]()!=null){
			toAdd = true;
			value += [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
		}
		else
			value+= "";
								[/let]
							[else]
		value += "[component.literal/]";
							[/if]
						[/for]
					[/if]
				[/if]
			[/if]
			[/let]
		[comment  No addition of key value pair when the value is null./]
		//No addition of key value pair when the value is null/empty.
		if(toAdd)
			SparkConnectionMgr.writeKeyValue(key,value,"[db.name/]");
		[/if]
[/template]

[template public generateValueForHashStructure(struct : AbstractPhysicalStructure, entityType: EntityType, suffix : String)]
	[comment Generate value for hash structure /]
boolean toAdd[suffix/] = false;
List<Tuple2<String,String>> hash[suffix/] = new ArrayList<>();
	[for (field : PhysicalField | struct.oclAsType(KeyValuePair).value.oclAsType(KVComplexField).fields)]
toAdd[suffix/] = false;
String [suffix/]_fieldname_[getPhysicalName(field)/]="[getPhysicalName(field)/]";
String [suffix/]_value_[getPhysicalName(field)/]="";
		[if (field.oclIsTypeOf(ShortField))]
				[let attr : Attribute = getMappedAttributes(field, entityType, entityType.getMappingRules())->any(true)]
					[if (attr.oclIsUndefined()=false)]
if([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]()!=null){
	toAdd[suffix/] = true;
	[suffix/]_value_[getPhysicalName(field)/] += [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
}
					[/if]
				[/let] 
		[/if]
		[if (field.oclIsTypeOf(LongField))]
		[comment LongField with only one component and is BracketsField /]
			[if (field.oclAsType(LongField).pattern->size()=1 and field.oclAsType(LongField).pattern->any(true).oclIsTypeOf(BracketsField))]
				[let brackets : BracketsField = field.oclAsType(LongField).pattern->any(true).oclAsType(BracketsField)]
					[let attr : Attribute = getMappedAttributes(field, entityType, entityType.getMappingRules())->any(true)]
					[if (attr.oclIsUndefined()=false)]
if([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]()!=null){
	toAdd[suffix/] = true;
	[suffix/]_value_[getPhysicalName(field)/] += [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
}
					[/if]
					[/let] 
				[/let]
			[else]
				[if (field.oclAsType(LongField).pattern->filter(BracketsField)->exists(b |getMappedAttributes(b, entityType, entityType.getMappingRules())->size()=0)=false)]
					[comment All BracketsField are mapped to the corresponding entity or composed of only one Terminal expression/]
					[comment LongField is composed of component, therefore can only be StringType /]
					[for (component : TerminalExpression | field.oclAsType(LongField).pattern)]
						[if (component.oclIsTypeOf(BracketsField))]
							[let attr : Attribute = getMappedAttributes(component.oclAsType(BracketsField), entityType, entityType.getMappingRules())->any(true)]
if([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]()!=null){
	toAdd[suffix/] = true;
	[suffix/]_value_[getPhysicalName(field)/] += [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
}
else
	[suffix/]_value_[getPhysicalName(field)/] += "";
							[/let]
						[else]
[suffix/]_value_[getPhysicalName(field)/] += "[component.literal/]";
						[/if]
					[/for]
				[/if]
			[/if]
		[/if]
[comment When value is null for a field in the hash we dont add it to the hash.  /]
// When value is null for a field in the hash we dont add it to the hash.
if(toAdd[suffix/])
	hash[suffix/].add(new Tuple2<String,String>([suffix/]_fieldname_[getPhysicalName(field)/],[suffix/]_value_[getPhysicalName(field)/]));
	[/for]

[comment]// A -> B[/comment]
[for (ref : Reference | getRefOfPhysicalStructure(struct))]
	[let role : Role = getMappedRoleOfReference(ref)]
		[if (role.isMandatoryRole())]
// Ref '[ref.name/]' mapped to role '[role.name/]'
hash[suffix/].add(new Tuple2<String,String>("[ref.sourceField->any(true).oclAsType(PhysicalField).getPhysicalName()/]",Util.getStringValue([role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][role.getRelationShipType().name.toUpperFirst()/].get[getMappedAttributeOfFieldInStructure(ref.targetField->any(true).oclAsType(PhysicalField), ref.targetField->any(true).oclAsType(PhysicalField).getAbstractPhysicalStructureNotEmbeddedObject()).name.toUpperFirst()/]())));
		[/if]
	[/let]
[/for]

[/template]

[template public generateDocument(entityType : EntityType, fields : Collection(PhysicalField), objectName : String, level : Integer, embeddedRoleLevel : Integer, newDoc : Boolean)]
[if(newDoc)]Document doc[objectName/]_[level/] = new Document();[/if]
[for (field : PhysicalField | fields)]
	[if (field.oclIsTypeOf(ShortField))]
		[let attr : Attribute = getMappedAttributes(field, entityType, entityType.getMappingRules())->any(true)]
			[if (attr.oclIsUndefined()=false)]
doc[objectName/]_[level/].append("[getPhysicalName(field)/]",[entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
			[/if]
		[/let] 
	[/if]
	[if (field.oclIsTypeOf(LongField))]
		[comment LongField with only one component and is BracketsField /]
		[if (field.oclAsType(LongField).pattern->size()=1 and field.oclAsType(LongField).pattern->any(true).oclIsTypeOf(BracketsField))]
			[let brackets : BracketsField = field.oclAsType(LongField).pattern->any(true).oclAsType(BracketsField)]
				[let attr : Attribute = getMappedAttributes(field, entityType, entityType.getMappingRules())->any(true)]
				[if (attr.oclIsUndefined()=false)]
doc[objectName/]_[level/].append("[getPhysicalName(field)/]",[entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
				[/if]
				[/let] 
			[/let]
		[else]
			[if (field.oclAsType(LongField).pattern->filter(BracketsField)->exists(b |getMappedAttributes(b, entityType, entityType.getMappingRules())->size()=0)=false)]
				[comment All BracketsField are mapped to the corresponding entity or composed of only one Terminal expression/]
				[comment LongField is composed of component, therefore can only be StringType /]
String value_[objectName/]_[getPhysicalName(field)/]_[level/] = "";
				[for (component : TerminalExpression | field.oclAsType(LongField).pattern)]
					[if (component.oclIsTypeOf(BracketsField))]
						[let attr : Attribute = getMappedAttributes(component.oclAsType(BracketsField), entityType, entityType.getMappingRules())->any(true)]
value_[objectName/]_[getPhysicalName(field)/]_[level/] += [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
						[/let]
					[else]
value_[objectName/]_[getPhysicalName(field)/]_[level/] += "[component.literal/]";
					[/if]
				[/for]
doc[objectName/]_[level/].append("[getPhysicalName(field)/]",value_[objectName/]_[getPhysicalName(field)/]_[level/]);
			[/if]
		[/if]
	[/if]
[comment]Verify if field mapped to reference[/comment]
[comment]	Reference fields [/comment]
[comment]// A -> B[/comment]
	[for (ref : Reference | getReferenceOfPhysicalField(field))]
		[let role : Role = getMappedRoleOfReference(ref)]
		[if (isMandatoryRole(role))]
// Ref '[ref.name/]' mapped to mandatory role '[role.name/]'
			[if (embeddedRoleLevel>0)]
	if([entityType.name.toLowerFirst()/]._get[role.getOppositeRoleInBinaryRel().name.toUpperFirst()/]()!=null){
doc[objectName/]_[level/].append("[ref.sourceField->any(true).oclAsType(PhysicalField).getPhysicalName()/]",[entityType.name.toLowerFirst()/]._get[role.getOppositeRoleInBinaryRel().name.toUpperFirst()/]().get[getMappedAttributeOfFieldInStructure(ref.targetField->any(true).oclAsType(PhysicalField), ref.targetField->any(true).oclAsType(PhysicalField).getAbstractPhysicalStructureNotEmbeddedObject()).name.toUpperFirst()/]());
	}else{
		logger.error("Physical Structure contains attribute or reference to an indirectly linked object. Please set role attribute '[role.getOppositeRoleInBinaryRel().name/]' of type '[role.getOppositeRoleInBinaryRel().entity.name.toUpperFirst()/]' in entity object '[entityType.name.toUpperFirst()/]");
		throw new PhysicalStructureException("Physical Structure contains attribute or reference to an indirectly linked object. Please set role attribute '[role.getOppositeRoleInBinaryRel().name/]' of type '[role.getOppositeRoleInBinaryRel().entity.name.toUpperFirst()/]' in entity object '[entityType.name.toUpperFirst()/]");
	}
			[else]
doc[objectName/]_[level/].append("[ref.sourceField->any(true).oclAsType(PhysicalField).getPhysicalName()/]",[role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][role.getRelationShipType().name.toUpperFirst()/].get[getMappedAttributeOfFieldInStructure(ref.targetField->any(true).oclAsType(PhysicalField), ref.targetField->any(true).oclAsType(PhysicalField).getAbstractPhysicalStructureNotEmbeddedObject()).name.toUpperFirst()/]());
			[/if]
		[/if]
	[/let]
	[/for]
[comment][/comment]
	[if (field.oclIsTypeOf(EmbeddedObject) and field.isMappedToRole(entityType.getMappingRules())=false)]
// Embedded structure [field.getPhysicalName()/]
		[if (getMappedAttributes(field, entityType, entityType.getMappingRules())->size()>0 or getDescendentsLongField(field)->exists(lf | lf.pattern->size()=1 and lf.pattern->any(true).oclIsTypeOf(BracketsField)=false))]
		[comment Generate only for embedded objects with at least one field mapped to the concerned ENT or a field composed only of a constant string. /]
	[generateDocument(entityType, field.oclAsType(EmbeddedObject).fields, field.getPhysicalName(), level+1,embeddedRoleLevel,true)/]
				[if (field.oclAsType(EmbeddedObject).cardinality= pml::Cardinality::ONE_MANY) or (field.oclAsType(EmbeddedObject).cardinality= pml::Cardinality::ZERO_MANY)]
	List<Document> array[field.getPhysicalName()/]_[level/] = new ArrayList();
	array[field.getPhysicalName()/]_[level/].add(doc[field.getPhysicalName()/]_[level+1/]);
	doc[objectName/]_[level/].append("[field.getPhysicalName()/]", array[field.getPhysicalName()/]_[level/]);
				[else]
	doc[objectName/]_[level/].append("[field.getPhysicalName()/]", doc[field.getPhysicalName()/]_[level+1/]);
				[/if]
		[/if]
	[else]
	[let role : Role = getMappedRoleOfPhysicalField(field)]
		[if (role.isMandatoryRole())]
// field '[field.getPhysicalName()/]' is mapped to mandatory role '[role.name/]' with opposite role of type '[role.getOppositeRoleInBinaryRel().entity.name/]'
			[if(embeddedRoleLevel>0)]
				[if (role.isCardinalityMaxN())]
	List<[role.getOppositeRoleInBinaryRel().entity.name.toUpperFirst()/]> [role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/] = [entityType.name.toLowerFirst()/]._get[role.getOppositeRoleInBinaryRel().name.toUpperFirst()/]List();
				[else]
		[role.getOppositeRoleInBinaryRel().entity.name.toUpperFirst()/] [role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/] = [entityType.name.toLowerFirst()/]._get[role.getOppositeRoleInBinaryRel().name.toUpperFirst()/]();
				[/if]
	if([role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/]==null [if (role.isCardinalityMaxN())]|| [role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/].size()==0[/if]){
		logger.error("Physical Structure contains embedded attributes or reference to an indirectly linked object. Please set role attribute '[role.getOppositeRoleInBinaryRel().name/]' of type '[role.getOppositeRoleInBinaryRel().entity.name.toUpperFirst()/]' in entity object '[entityType.name.toUpperFirst()/]");
		throw new PhysicalStructureException("Physical Structure contains embedded attributes or reference to an indirectly linked object. Please set role attribute '[role.getOppositeRoleInBinaryRel().name/]' of type '[role.getOppositeRoleInBinaryRel().entity.name.toUpperFirst()/]' in entity object '[entityType.name.toUpperFirst()/]");
	}
			[/if]
			[if (role.isCardinalityMaxN())]
	List<Document> array[field.getPhysicalName()/]_[level/] = new ArrayList();
		for([role.getOppositeRoleInBinaryRel().entity.name.toUpperFirst()/] [role.getOppositeRoleInBinaryRel().entity.name.toLowerFirst()/] : [role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/]){
			[generateDocument(role.getOppositeRoleInBinaryRel().entity, field.oclAsType(EmbeddedObject).fields, field.getPhysicalName(), level+1,embeddedRoleLevel+1,true)/]
			array[field.getPhysicalName()/]_[level/].add(doc[field.getPhysicalName()/]_[level+1/]);
		}
	doc[objectName/]_[level/].append("[field.getPhysicalName()/]", array[field.getPhysicalName()/]_[level/]);
			[else]
		[role.getOppositeRoleInBinaryRel().entity.name.toUpperFirst()/] [role.getOppositeRoleInBinaryRel().entity.name.toLowerFirst()/] = [role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/];
		[generateDocument(role.getOppositeRoleInBinaryRel().entity, field.oclAsType(EmbeddedObject).fields, field.getPhysicalName(), level+1,embeddedRoleLevel+1,true)/]
		[if (getMappedAttributes(field, entityType, entityType.getMappingRules())->size()>0 or getDescendentsLongField(field)->exists(lf | lf.pattern->size()=1 and lf.pattern->any(true).oclIsTypeOf(BracketsField)=false))]
			// Embedded attributes of '[entityType.name.toUpperFirst()/]' in '[field.getPhysicalName()/]' which is also mapped to a role.
		[comment Generate only for embedded objects with at least one field mapped to the concerned ENT or a field composed only of a constant string. /]
			[generateDocument(entityType, field.oclAsType(EmbeddedObject).fields, field.getPhysicalName(), level+1,embeddedRoleLevel,false)/]
		[/if]
		doc[objectName/]_[level/].append("[field.getPhysicalName()/]", doc[field.getPhysicalName()/]_[level+1/]);
			[/if]
		[/if]
	[/let]
	[/if]
[/for]
[/template]

[template public generateStructField(entityType : EntityType, fields : Collection(PhysicalField), objectName : String, level : Integer, inEmbeddedRole : Boolean)]
[if (not inEmbeddedRole)]
List<Object> values[objectName/]_[level/] = new ArrayList<>();
List<StructField> listOfStructField[objectName/]_[level/] = new ArrayList<StructField>();
[/if]
[for (field : PhysicalField | fields)]
	[if (field.oclIsTypeOf(ShortField))]
		[let attr : Attribute = getMappedAttributes(field, entityType, entityType.getMappingRules())->any(true)]
			[if (attr.oclIsUndefined()=false)]
if(!listOfStructField[objectName/]_[level/].contains(DataTypes.createStructField("[getPhysicalName(field)/]",[generateSparkDataType(attr.type)/], true)))
	listOfStructField[objectName/]_[level/].add(DataTypes.createStructField("[getPhysicalName(field)/]",[generateSparkDataType(attr.type)/], true));
values[objectName/]_[level/].add([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
			[/if]
		[/let] 
	[/if]
	[if (field.oclIsTypeOf(LongField))]
		[comment LongField with only one component and is BracketsField /]
		[if (field.oclAsType(LongField).pattern->size()=1 and field.oclAsType(LongField).pattern->any(true).oclIsTypeOf(BracketsField))]
			[let brackets : BracketsField = field.oclAsType(LongField).pattern->any(true).oclAsType(BracketsField)]
				[let attr : Attribute = getMappedAttributes(field, entityType, entityType.getMappingRules())->any(true)]
				[if (attr.oclIsUndefined()=false)]
listOfStructField[objectName/]_[level/].add(DataTypes.createStructField("[getPhysicalName(field)/]",[generateSparkDataType(attr.type)/], true));
values[objectName/]_[level/].add([entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]());
				[/if]
				[/let] 
			[/let]
		[else]
			[if (field.oclAsType(LongField).pattern->filter(BracketsField)->exists(b |getMappedAttributes(b, entityType, entityType.getMappingRules())->size()=0)=false)]
				[comment All BracketsField are mapped to the corresponding entity or composed of only one Terminal expression/]
				[comment LongField is composed of component, therefore can only be StringType /]
String value_[objectName/]_[getPhysicalName(field)/]_[level/] = "";
				[for (component : TerminalExpression | field.oclAsType(LongField).pattern)]
					[if (component.oclIsTypeOf(BracketsField))]
						[let attr : Attribute = getMappedAttributes(component.oclAsType(BracketsField), entityType, entityType.getMappingRules())->any(true)]
value_[objectName/]_[getPhysicalName(field)/]_[level/] += [entityType.name.toLowerFirst()/].get[attr.name.toUpperFirst()/]();
						[/let]
					[else]
value_[objectName/]_[getPhysicalName(field)/]_[level/] += "[component.literal/]";
					[/if]
				[/for]
if(!listOfStructField[objectName/]_[level/].contains(DataTypes.createStructField("[getPhysicalName(field)/]",DataTypes.StringType, true)))
	listOfStructField[objectName/]_[level/].add(DataTypes.createStructField("[getPhysicalName(field)/]",DataTypes.StringType, true));
values[objectName/]_[level/].add(value_[objectName/]_[getPhysicalName(field)/]_[level/]);
			[/if]
		[/if]
	[/if]
[comment]Verify if field mapped to reference[/comment]
[comment]	Reference fields [/comment]
[comment]// A -> B[/comment]
	[for (ref : Reference | getReferenceOfPhysicalField(field))]
		[let role : Role = getMappedRoleOfReference(ref)]
		[if (isMandatoryRole(role))]
// Ref '[ref.name/]' mapped to mandatory role '[role.name/]'
listOfStructField[objectName/]_[level/].add(DataTypes.createStructField("[ref.sourceField->any(true).oclAsType(PhysicalField).getPhysicalName()/]",DataTypes.StringType, true));
values[objectName/]_[level/].add([role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][role.getRelationShipType().name.toUpperFirst()/].get[getMappedAttributeOfFieldInStructure(ref.targetField->any(true).oclAsType(PhysicalField), ref.targetField->any(true).oclAsType(PhysicalField).getAbstractPhysicalStructureNotEmbeddedObject()).name.toUpperFirst()/]());
		[/if]
	[/let]
	[/for]
[comment][/comment]
	[if (field.oclIsTypeOf(EmbeddedObject) and field.isMappedToRole(entityType.getMappingRules())=false)]
	Object row_value_[field.getPhysicalName()/]_[level+1/] = null;
// Embedded structure [field.getPhysicalName()/]
		[if (getMappedAttributes(field, entityType, entityType.getMappingRules())->size()>0 or getDescendentsLongField(field)->exists(lf | lf.pattern->size()=1 and lf.pattern->any(true).oclIsTypeOf(BracketsField)=false))]
		[comment Generate only for embedded objects with at least one field mapped to the concerned ENT or a field composed only of a constant string. /]
				[generateStructField(entityType, field.oclAsType(EmbeddedObject).fields, field.getPhysicalName(), level+1,false)/]
		StructType structType_[objectName/]_[level/] = DataTypes.createStructType(listOfStructField[field.getPhysicalName()/]_[level+1/]);
				[if (field.oclAsType(EmbeddedObject).cardinality= pml::Cardinality::ONE_MANY) or (field.oclAsType(EmbeddedObject).cardinality= pml::Cardinality::ZERO_MANY)]
		ArrayType array[field.getPhysicalName()/]_[level/] = DataTypes.createArrayType(structType_[objectName/]_[level/]);
		listOfStructField[objectName/]_[level/].add(DataTypes.createStructField("[field.getPhysicalName()/]",array[field.getPhysicalName()/]_[level/],true));
		row_value_[field.getPhysicalName()/]_[level+1/] = Arrays.asList(RowFactory.create(values[field.getPhysicalName()/]_[level+1/].toArray()));
				[else]
		listOfStructField[objectName/]_[level/].add(DataTypes.createStructField("[field.getPhysicalName()/]",structType_[objectName/]_[level/], true));
		row_value_[field.getPhysicalName()/]_[level+1/] = RowFactory.create(values[field.getPhysicalName()/]_[level+1/].toArray());
				[/if]
		values[objectName/]_[level/].add(row_value_[field.getPhysicalName()/]_[level+1/]);
		[/if]
	[else]
	[let role : Role = getMappedRoleOfPhysicalField(field)]
	[if (role.isMandatoryRole())]
// field '[field.getPhysicalName()/]' is mapped to mandatory role '[role.name/]' with opposite role of type '[role.getOppositeRoleInBinaryRel().entity.name/]'
	List<Object> values[field.getPhysicalName()/]_[level+1/] = new ArrayList<>();
	List<StructField> listOfStructField[field.getPhysicalName()/]_[level+1/] = new ArrayList<StructField>();
	if([role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/]!=null){
	[if (role.isCardinalityMaxN())]
	List<Row> row_value_[field.getPhysicalName()/]_[level+1/] = new ArrayList<>();
		for([role.getOppositeRoleInBinaryRel().entity.name.toUpperFirst()/] [role.getOppositeRoleInBinaryRel().entity.name.toLowerFirst()/] : [role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/]){
			values[field.getPhysicalName()/]_[level+1/].clear();
			[generateStructField(role.getOppositeRoleInBinaryRel().entity, field.oclAsType(EmbeddedObject).fields, field.getPhysicalName(), level+1, true)/]
			row_value_[field.getPhysicalName()/]_[level+1/].add(RowFactory.create(values[field.getPhysicalName()/]_[level+1/].toArray()));
		}
	StructType structType_[field.getPhysicalName()/]_[level/] = DataTypes.createStructType(listOfStructField[field.getPhysicalName()/]_[level+1/]);
	ArrayType array[field.getPhysicalName()/]_[level/] = DataTypes.createArrayType(structType_[field.getPhysicalName()/]_[level/]);
	listOfStructField[objectName/]_[level/].add(DataTypes.createStructField("[field.getPhysicalName()/]",array[field.getPhysicalName()/]_[level/],true));
	values[objectName/]_[level/].add(row_value_[field.getPhysicalName()/]_[level+1/]);
	[else]
		Row row_value_[field.getPhysicalName()/]_[level+1/];
		[role.getOppositeRoleInBinaryRel().entity.name.toUpperFirst()/] [role.getOppositeRoleInBinaryRel().entity.name.toLowerFirst()/] = [role.getOppositeRoleInBinaryRel().name.toLowerFirst()/][getRelationShipType(role).name.toUpperFirst()/];
		[generateStructField(role.getOppositeRoleInBinaryRel().entity, field.oclAsType(EmbeddedObject).fields, field.getPhysicalName(), level+1,true)/]
		StructType structType_[field.getPhysicalName()/]_[level/] = DataTypes.createStructType(listOfStructField[field.getPhysicalName()/]_[level+1/]);
		listOfStructField[objectName/]_[level/].add(DataTypes.createStructField("[field.getPhysicalName()/]",structType_[field.getPhysicalName()/]_[level/],true));
		row_value_[field.getPhysicalName()/]_[level+1/] = RowFactory.create(values[field.getPhysicalName()/]_[level+1/].toArray());
		values[objectName/]_[level/].add(row_value_[field.getPhysicalName()/]_[level+1/]);
	[/if]
	}
	[/if]
	[/let]
	[/if]
[/for]
[/template]

